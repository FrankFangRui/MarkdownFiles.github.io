 **目录**

[1.线程和进程的介绍](#1、线程和进程的介绍)

[1.线程和进程的引入](#1.线程和进程的引入)

[2.并发和并行的区别](#2.并发和并行的区别)

[ 3.为什么多进程不能取代多线程？](# 3.为什么多进程不能取代多线程？)

[1.频繁地创建销毁进程是个低效的操作](#1.因为如果频繁地创建销毁进程，这个操作就比较低效)

[2.线程创建和销毁的开销比进程的少](#2.线程创建和销毁的开销比进程的少)

[非常重要的面试题：谈谈进程和线程之间的区别！【高频】 谈到操作系统，进程线程的概念和区别，就是出场频率最高的问题（没有之一）](#非常重要的面试题：谈谈进程和线程之间的区别！【高频】 谈到操作系统，进程线程的概念和区别，就是出场频率最高的问题（没有之一）)

[2.线程的创建和调用](#2.线程的创建和调用)

[1.线程的创建方式](#1.线程的创建方式)

[方法1：继承Thread类，重写run方法](#方法1：继承Thread类，重写run方法)

[方法2：实现Runnable接口](#方法2：实现Runnable接口)

[方法3：使用匿名内部类，实现了创建 Thread 子类的方式](#3.使用匿名内部类，实现了创建 Thread 子类的方式)

[方法4：使用匿名内部类，实现 Runnable 接口的方式](#4.使用匿名内部类，实现 Runnable 接口的方式)

[方法5：用lambda表达式](#5.用lambda表达式)

[2.调用线程的优势](#2.调用线程的优势)

[3.关于线程调度的随机性](#3.关于线程调度的随机性)

[4.变量捕获](#4.变量捕获)



[3.线程的中断](#3.线程的中断)

[1. interrupt() 方法](#1. interrupt() 方法)

[2.interrupted()方法](#2.interrupted()方法)

[3.isInterrupted（） 方法](#3.isInterrupted（） 方法)

[4.线程的状态编辑](#4.线程的状态编辑)

[1.新建状态 New](#1.新建状态 New)

[2.可运行状态 Runnable](#2.可运行状态 Runnable)

[3.阻塞状态 Blocked](#3.阻塞状态 Blocked)

[4.等待状态 Waiting](#4.等待状态 Waiting)

[5.计时等待 Timed waiting](#5.计时等待 Timed waiting)

[6.终止状态 Terminated](#6.终止状态 Terminated)

[5.线程安全](#5.线程安全)

[1. 操作系统对于线程的调度是抢占式的](#1. 抢占式执行)

[2.多个线程修改同一个变量](#2.多个线程修改同一个变量)

[3. 修改操作不是原子性的](#3. 原子性)

[synchronized关键字](#synchronized关键字)

[1、synchronized 关键字的作用](#1、synchronized 关键字的作用)

[2、锁的可重入性](#2、锁的可重入性)

[4.内存可见性问题](#4.内存可见性问题)

[volatile 关键字](#volatile 关键字)

[1.wait 和 notify](#1.wait 和 notify)

[多线程案例](#多线程案例)

[1.单例模式](#1.单例模式)



[阻塞队列](#阻塞队列)

[1.生产消费者模型](#1.生产消费者模型)

[优势1： 使用阻塞队列，有利于代码“解耦合”](#优势1： 使用阻塞队列，有利于代码“解耦合”)

[ 优势2：削峰填谷](# 优势2：削峰填谷)

[阻塞队列的具体使用](#阻塞队列的具体使用)

[2.定时器](#2.定时器)



# 1.线程和进程的介绍

## 1.线程和进程的引入

   什么是线程（Thread)？

   线程是系统（CPU和操作系统共同完成）能够进行**调度执行**的基本单位。大部分情况下，它被包含在进程之中，是进程中的实际运算单位。

   什么是进程（Process)？

   进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行**资源分配**和调度的基本单位

   在使用者下达执行程序的命令之后，就会产生进程。同一程序可产生多个进程（一对多关系），以允许同时有多位使用者执行同一程序，却不会相冲突。

  进程存在的意义：让操作系统可以同时执行多个任务，实现了“并发编程”的效果

## 2.并发和并行的区别

> 并发(Concurrent)：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。(例如：在一个CPU上交替执行两个任务)
>
> 并行(Parallel)：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行。（例如：两个程序在两个CPU上同时执行，因为CPU执行速度很快，很难察觉出两者的差异）

![img](https://img-blog.csdnimg.cn/59bfacf4d0fa498e94266c1dc13d26ab.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

>  我们两个人在吃午饭。你在吃饭的整个过程中，吃了米饭、吃了蔬菜、吃了牛肉。吃米饭、吃蔬菜、吃牛肉这三件事其实就是并发执行的。对于你来说，整个过程中看似是同时完成的的。但其实你是在吃不同的东西之间来回切换的。
>
> 
>
> 还是我们两个人吃午饭。在吃饭过程中，你吃了米饭、蔬菜、牛肉。我也吃了米饭、蔬菜和牛肉。我们两个人之间的吃饭就是并行的。两个人之间可以在同一时间点一起吃牛肉，或者一个吃牛肉，一个吃蔬菜。之间是互不影响的。
>
> 
>
> 并发，指的是多个事情，在同一时间段内同时发生了。
>
> 并行，指的是多个事情，在同一时间点上同时发生了。
>
> 并发的多个任务之间是互相抢占资源的。
>
> 并行的多个任务之间是不互相抢占资源的、
>
> 只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。

![img](https://img-blog.csdnimg.cn/b695ecf488894f5084b027904979a6b3.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

##  3.为什么多进程不能取代多线程？

### **1.频繁地创建销毁进程是个低效的操作**

> 例如写一个服务器程序
>  就可以针对每个客户端，分别创建一个进程，提供服务
>
> 
>
> 服务器这里可能有多个客服端 来来回回
>  每次有个新客户端来了，都得创建一个进程来服务，客服端走了，进程就销毁了

**创建销毁进程效率低的原因是其步骤复杂**

> （了解创建销毁进程是复杂的即可）
>
> 进程创建步骤：
>  1、创建PCB
>  2、给进程分配资源（内存/文件），赋值到PCB中 --> 分配资源这个事情，对于操作系统来说是一个大活！
>  3、把PCB插入链表
>
> 进程销毁的步骤
>  1、把PCB从链表上删除
>  2、把PCB中持有的资源释放 --> 比较消耗时间！
>  3、销毁PCB

![img](https://img-blog.csdnimg.cn/820150bd27c84c04ad489020bb76c09c.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



**上述关于进程创建销毁的内容可能对初学者来说不好理解，可以换一种方式思考**

**进程的创建：**

> java中的进程类是Process。每一个程序的运行基本上都会开启一个进程，然后执行进程的主线程。所以很多时候，我们并不直接去使用代码来创建一个进程，而是交由系统来为每一个程序自动创建进程。执行Java程序都伴随着Java虚拟机的执行，每一个程序都对应着一个虚拟机，可以理解为每一个虚拟机的启动就是一个进程的启动（当然其他语言就不是虚拟机，但是也有进程的概念），然后启动该进程的主线程，由主线程启动其他线程。对应的就是可执行的Java程序中必不可少的一个main方法，main方法是程序的起点，是程序的初始线程，其他线程都由它启动。

通过代码启动一个进程（创建一个文件）的方法：在java.lang.Runtime类和Java.lang.ProcessBuilder可以来创建一个本地的进程。

具体的使用方法如下（Java1.8）

```java
//打开指定路径的文件夹

Process p1 =Runtime.getRuntime().exec("open /Users/anonyper/Desktop/未命名文件夹");

Process p2 = new ProcessBuilder("open", "/Users/anonyper/Desktop/未命名文件夹").start();
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**进程的销毁：**

只要java虚拟机中还有普通线程(用户线程)在执行，那么虚拟机就不会停止，当没有普通线程时，虚拟机中都是守护线程的话，则虚拟机（该进程）就会退出。



### 2.线程创建和销毁的开销比进程的少

用一种抽象的方式可以更加对进程和线程的创建销毁哪个快捷的理解更加深刻

一个程序相当于一个进程，打开一份代码文件就是创建一个进程

在一个代码文件中，可以创建多个进程，在代码中创建销毁线程，肯定比在内存中创建销毁进程（文件）快捷的多了

如果把进程想象成工厂，线程就是工厂中的“流水线”，拆除一条流水线肯定比拆除一个工厂快捷。

## **非常重要的面试题：谈谈进程和线程之间的区别！【高频】 谈到操作系统，进程线程的概念和区别，就是出场频率最高的问题（没有之一）**

进程线程的概念：

线程是系统进行**调度执行**的基本单位。大部分情况下，它被包含在进程之中，是进程中的实际运算单位。

进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行**资源分配**和调度的基本单位

描述进程与线程的区别主要考虑以下四个方面：

1. 首先说明进程与线程之间的关系 ： **进程中包含一条或多条线程；**
2. 第二从系统管理与分配资源和CPU调度的角度来分析：**进程是系统分配资源的最小单位，线程是CPU调度的最小单位；**
3. 第三从资源使用角度来分析：**进程之间不能共享资源，进程中的线程之间共享进程的所有资源；**
4. 单独介绍一下线程的特点：**线程的创建、销毁、调度效率比进程更高，并且有自己独立的执行任务**

# **2.线程的创建和调用**

## **1.线程的创建方式**

### **方法1：继承Thread类，重写run方法**

```java
public class Thread1 {
    public static void main(String[] args) {
        //Thread t = new MyThread(); 利用多态
        //实例化一个线程对象
        MyThread t = new MyThread();
        //真正的去申请系统线程，参与CPU调度
        t.start();
    }
}
//定义一个Thread类，相当于一个线程的模板
class MyThread extends Thread{
    // 重写run方法 run方法描述的是线程要执行的具体任务
    public void run(){
        System.out.println("hello thread");
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

### 方法2：实现Runnable接口

```java
public class Thread2 {
    public static void main(String[] args) {
        // 实例化Runnable对象
        MyRunnable myRunnable = new MyRunnable();
        // 实例化线程对象并绑定任务
        Thread t = new Thread(myRunnable);
        // Thread t = new Thread(new MyRunnable());
        // 真正的去申请系统线程参与CPU调度
        t.start();
    }
}
// 创建一个Runnable的实现类，并实现run方法
// Runnable主要描述的是线程的任务
class MyRunnable implements Runnable{
    public void run(){
        System.out.println("hello thread");
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

方法2把线程要干的活和线程本身分开了，使用Runnable来专门表示“线程要完成的工作”

把任务提取出来，目的是为了解耦合

方法1继承了Thread类的写法，就把线程要完成的任务和线程本身耦合在一起

假设未来要对这个代码进行调整（不用多线程，采用其他方法）

代码改动就比较大，因为代码的耦合度太高了，而实现Runnable接口这种写法，只需要把Runnable传给其他的实体即可。

### 方法3：使用匿名内部类，实现了创建 Thread 子类的方式

```java
public class Thread3 {
    public static void main(String[] args) {
        Thread t = new Thread(){
            public void run(){
                System.out.println("hello thread");
            }
        };
        t.start();
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

### 方法4：使用匿名内部类，实现 Runnable 接口的方式

```java
public class Thread4 {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable(){
            public void run(){
                System.out.println("hello thread");
            }
        });
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

### 方法5：用lambda表达式

```java
public class Thread5 {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            // 指定任务：任务是循环打印当前线程名
            while (true) {
                System.out.println(Thread.currentThread().getName());
                try {
                    // 休眠1000ms
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        // 申请系统线程参与CPU调度
        t.start();
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

## 2.调用线程的优势

使用多线程，会有一定的优势，能够更充分地利用多核CPU，提高程序的效率

代码1:不使用多线程

两个for循环在同一个线程（main线程）中执行

```java
public class Thread6 {
    public static final long COUNT = 1000000000;
    public static void main(String[] args){
        serial();
    }
    public static void serial(){
        //记录 ms 级别的时间戳
        long beg = System.currentTimeMillis();
        long a = 0;
        for(long i = 0 ; i < COUNT ; i++){
            a++;
        }
        a = 0;
        for(long i = 0 ; i < COUNT ; i++){
            a++;
        }
        long end = System.currentTimeMillis();
        System.out.println("执行的时间间隔：" + (end - beg) + "ms");

    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

执行结果：

![img](https://img-blog.csdnimg.cn/f1bc5f14b42e4288bdb0f4e5333e3721.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

代码2：使用多线程

两个for循环分别由两个线程执行，在main线程中调用这两个线程

```java
public class Thread6 {
    public static final long COUNT = 1000000000;
    public static void main(String[] args){
        serial();
    }
    public static void serial(){
        //记录 ms 级别的时间戳
        long beg = System.currentTimeMillis();
        long a = 0;
        Thread t1 = new Thread(() -> {
            long a = 0;
            for(long i = 0 ; i < COUNT ; i++){
                a++;
            }
        });
        Thread t2 = new Thread(() -> {
            long a = 0;
            for(long i = 0 ; i < COUNT ; i++){
                a++;
            }

        });

        t1.start();
        t2.start();

        // t1、t2 线程 start（）之后，到t1、t2 join()的时间忽略不计，如果计算量小，影响就大，计算量大，印象就小
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e){
            e.printStackTrace();
        }
        long end = System.currentTimeMillis();
        System.out.println("执行的时间间隔：" + (end - beg) + "ms");

    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

执行结果： 

![img](https://img-blog.csdnimg.cn/47ac3c6f08c945fda0c7a6ca859de6a0.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



通过代码1和代码2的执行结果来看，使用多线程能够明显提高程序的运行效率

我们也可以发现

1.同样的代码，每次运行的结果还是会有差异

2.使用两个线程并发执行和单个线程并行执行，在执行的时间间隔上并没有两倍的关系

## 3.关于线程调度的随机性

线程的调度由系统决定，所以代码结果输出的顺序和输出语句在代码中的位置没有直接关系

```java
public static void main(String[] args) {
    Thread t = new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println("1");
        }
    });
    t.start();
    // 其实就是看系统执行下方 输出2 的语句快，还是t.start()之后执行t线程中的 输出1 的语句快
    System.out.println("2");
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

由于打印1 和 打印2分别在不同的线程中执行，具体先执行哪个线程是由系统决定的，且无法预测，所以两种情况都有可能。 

但是从实际运行来看 先输出2 的概率比 先输出1 的概率大

如果在 t.start() 和 System.out.println(“2”）之间增加一些运算量 来增加运行 输出2 所要的时间的话，情况就会变化

```java
        t.start();
        long a = 0;
        for(int i = 0 ; i < 100000000 ; i++){
            a++;
        }
        // 其实就是看系统执行下方 输出2 的语句快，还是t.start()之后执行t线程中的 输出1 的语句快
        System.out.println("2");
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

此时输出结果大概率就会先输出 1 然后 输出 2

仍需要注意的是：线程的调度由系统决定，由于系统还要调度其他程序所以内部情况十分复杂，也许下次调度 t 线程的速度变慢，那么就会先输出 2 ，上诉程序的目的就是为了告诉大家：

 **线程的调度由系统决定，是随机调度的**

如果两个线程同时调用 start （调用间隔很短）看系统的调度（随机）

如果一个线程先 start 然后 sleep 一段时间再调用下一个线程的 start ，就会有先后顺序了





![img](https://img-blog.csdnimg.cn/3c6d9fbc1569483583fd179c3e6e5830.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



## 4.变量捕获

因为在使用匿名内部类的时候，内部类相当于另外一个类，所以原本创造线程中的变量，在内部类中应该无法访问，但是java开了一个口子——变量捕获，将类外面的局部变量，给捕获到类里面来（捕获的前提是这个变量虽然没有final修饰，但是不能修改）

```java
public class Thread2_4 {
    public static void main(String[] args) {
        int a = 1;
        Thread t = new Thread(){
            public void run(){
                if(a == 1){
                    System.out.println("t线程结束");
                }
            }
        };
        t.start();
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

# 

如果有修改，则会报错

![img](https://img-blog.csdnimg.cn/c2d2c9529fd74b8a806af0be3a90548b.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

![img](https://img-blog.csdnimg.cn/81d58d13b5e04cbf8cc2f562db0b3e7a.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 想要绕开变量捕获，只要把变量设置为类的成员变量，就能在内部类中修改

```java
public class Thread2_4 {
    static int a = 1;
    public static void main(String[] args) {
        Thread t = new Thread(){
            public void run(){
                a = 2;
                if(a == 1){
                    System.out.println("t线程结束");
                }
            }
        };
        t.start();
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

# **3.线程的中断**

说到线程的中断，一定离不开三个 方法 interrupt() , interrupted() , isInterrupted() ， 我们从源代码入手就能很好地理解这三个方法

## 1. interrupt() 方法

```java
 public void interrupt() {
        if (this != Thread.currentThread()) {
            checkAccess();

            // thread may be blocked in an I/O operation
            synchronized (blockerLock) {
                Interruptible b = blocker;
                if (b != null) {
                    interrupt0();  // set interrupt status
                    b.interrupt(this);
                    return;
                }
            }
        }

        // set interrupt status
        interrupt0();
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> Interrupts this thread.
>  Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.
>
> 
>
> 中断这个线程，除非当前线程正在中断自己(这总是被允许的)，否则调用该线程的checkAccess方法，这可能导致抛出SecurityException。
>
> 
>
> If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException. 
>  If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException. 
>  If this thread is blocked in a java.nio.channels.Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked. 
>  If none of the previous conditions hold then this thread's interrupt status will be set. 
>  Interrupting a thread that is not alive need not have any effect. 
>
> 
>
> 如果这个线程在调用Object类的wait()、wait(long)或wait(long, int)方法，或该类的join()、join(long)、join(long, int)、sleep(long)或sleep(long, int)方法时被阻塞，那么它的中断状态将被清除，并将接收InterruptedException。
>
> 如果该线程在InterruptibleChannel上的I/O操作中被阻塞，那么该通道将被关闭，线程的中断状态将被设置，并且该线程将收到java.nio.channels.ClosedByInterruptException。
>
> 如果这个线程在java.nio.channels.Selector中被阻塞，那么线程的中断状态将被设置，并且它将立即从选择操作返回，可能返回一个非零值，就像调用了选择器的唤醒方法一样。
>
> 如果前面的条件都不满足，那么这个线程的中断状态将被设置。
>
> 中断不活动的线程不需要产生任何影响



interrupt方法的作用是**中断此线程**（**注意：此线程不一定指当前线程，比如在main方法中执行，并一定指main线程，而是指调用这个方法的Thread实例所代表的线程**），但实际上**只是给线程设置了一个中断标志，线程仍然会继续运行**

## 2.interrupted()方法

```java
public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }


/**
     * Tests if some Thread has been interrupted.  The interrupted state
     * is reset or not based on the value of ClearInterrupted that is
     * passed.
     * 测试某些线程是否已中断。中断状态将根据传递的“清除中断”的值重置或不重置
     */

是否中断的标志：
 @HotSpotIntrinsicCandidate
    private native boolean isInterrupted(boolean ClearInterrupted);
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> Tests whether the current thread has been interrupted. The interrupted status of the thread is cleared by this method. In other words, if this method were to be called twice in succession, the second call would return false (unless the current thread were interrupted again, after the first call had cleared its interrupted status and before the second call had examined it).
>  A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.
>  Returns:
>  true if the current thread has been interrupted; false otherwise.
>  
>
> **此方法可以验证当前线程是否已经被中断。在调用这个方法之后，当前线程的中断状态会被清除。**换句话说，如果这个方法被连续调用两次，第二次调用的时候会返回 false (线程没有中断），除非当前线程被再次中断（在连续两次调用interrupted()之间再被中断，尽管第一次调用的时候已经清楚了当前线程的中断状态，但是再次中断使当前线程又处于中断状态，相当于回到第一次中断的状态），
>
> 由于线程在中断时未处于活动状态而被忽略的线程中断将通过此方法返回 false 来反映。

interrupted方法的作用是**验证当前线程是否被中断，返回一个boolean值并且清除中断状态**（通过源代码可以得知 interrupted 方法 调用 isInterrupted 方法来验证当前线程是否中断，然后通过 传送 ClearInterrupted 为 true 的值给 isInterrupted（）方法来确定重置中断状态。

因为interrupted()是一个静态方法，在使用这个方法的时候，时刻要注意此方法验证的是当前线程（current thread)，而不是调用这个方法的Thread实例所在的线程，我们可以通过一段代码来理解这个"当前"

```java
public class Thread3_2 {
    public static void main(String[] args) {
        Thread t = new Thread(){
            public void run(){
                System.out.println("hello thread");
            }
        };
        t.start();
        t.interrupt();
        System.out.println("使用 isInterrupted() 方法检测t线程是否中断：" + t.isInterrupted());
        System.out.println("第一次使用 interrupted() 方法检测t线程是否中断：" + t.interrupted());
        System.out.println("第二次使用 interrupted() 方法检测t线程是否中断：" + t.interrupted());
        System.out.println("第三次使用 interrupted() 方法检测t线程是否中断：" + Thread.interrupted());
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

 输出结果：

![img](https://img-blog.csdnimg.cn/87e75baa87c6474d8fa1f9fed2495de9.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 因为调用interrupted()方法的是当前线程，所以interrupted()方法检测的并不是 t 线程，而是main线程，所以第一次使用 interrupted()方法的时候，返回值是 false,表示main线程未中断，因为interrupted()方法是静态方法，所以用实例调用（t.interrupted())和用类名调用(Thread.interrupted())是一样的效果。



可以通过Thread.currentThread()方法来获取当前线程，来验证interrupted()方法调用的是当前线程

```java
public static void main(String[] args ) throws InterruptedException {
            Thread.currentThread().interrupt();
            System.out.println("第一次调用Thread.currentThread().interrupt()："
                    +Thread.currentThread().isInterrupted());
            System.out.println("第一次调用thread.interrupted()："
                    +Thread.currentThread().interrupted());
            System.out.println("第二次调用thread.interrupted()："
                    +Thread.currentThread().interrupted());
        }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

输出结果：

![img](https://img-blog.csdnimg.cn/49bc8ceefb6d4224bb0169f686f96e4b.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

如果想要在通过interrupted()方法来终止指定的线程，只需要在目标线程的run方法中进行操作，比如直接终止run()方法来使线程结束



## 3.isInterrupted（） 方法

```java
    public boolean isInterrupted() {
        return isInterrupted(false);
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> Tests whether this thread has been interrupted. The interrupted status of the thread is unaffected by this method.
>  A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.
>  Returns:
>  true if this thread has been interrupted; false otherwise. 
>
> 测试此线程是否已中断。线程的中断状态不受此方法的影响。
>  由于线程在中断时未处于活动状态而被忽略的线程中断将通过此方法返回 false 来反映。
>  返回：
>  如果此线程已中断，则为 true;否则为假。

此方法的作用就是**判断线程是否已经中断**， 同时此方法会给isInterrupted()变量传送ClearInterrupted 值为 false 的变量，表示不要重置中断状态。

# 4.线程的状态![img](https://img-blog.csdnimg.cn/2b8358673d2a426aac2fca1cbec2f704.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 线程状态一共有六种：

> New(新建）
>
> Runnable(可运行）
>
> Blocked(阻塞）
>
> Waiting(等待）
>
> Timed waiting(计时等待）
>
> Terminated(终止）

我们要确定一个线程的当前状态，只需要调用getState()方法

## 1.新建状态 New

```java
Thread t = new Thread();
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

用new操作符创建一个新线程时，这个线程还没有运行，意味着这个线程的状态处于新建状态

## 2.可运行状态 Runnable

```java
t.start();
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

当新建完一个线程之后，调用 start() 方法，线程就处于可运行状态。

**一个可运行的线程可能正在运行也可能没有运行**

一个处于可运行状态的线程是否运行取决于操作系统对于时间片的分配，当一个线程分配到了一个时间片，就开始运行，时间片用完时，操作系统就会剥夺该线程的运行权，并给另一个线程一个机会来运行。

## 3.阻塞状态 Blocked

当线程处于阻塞或等待状态时，它暂时是不活动的。它不运行任何代码，而且消耗最少的资源。

当一个线程试图获取一个内部的对象锁（而不是 java.util.concurrent 库中的 Lock)，而这个锁目前被其他线程占有，该线程就会被阻塞。当所有其他线程都是放了这个锁，并且线程调度器允许该线程持有这个锁的时候，它将变成非阻塞状态。

## 4.等待状态 Waiting



## 5.计时等待 Timed waiting

## 6.终止状态 Terminated

线程终止有两个原因：

1.run方法正常退出，线程自然终止

2.因为一个没有捕获的异常终止了run方法，使线程意外终止

# 5.线程安全

有些代码在多线程环境下执行会出现BUG，这样的问题就称为"线程不安全"

就像两个人同时从一张银行卡里把钱取完，当一个人取完钱的时候，同时取的另一个人的账户上的钱数没有更新，也把钱取了出来，造成了银行的损失，这就是线程不安全

线程不安全的原因：

## 1. 操作系统对于线程的调度是抢占式的

出现线程安全问题的根本问题就是线程的抢占式执行

抢占式执行意思就是，当某个线程正在执行，在就绪队列中有一个更高优先级的任务出现了，当前任务就会被抢占（中断），那个更高优先级的线程就会上位被执行即获取到 CPU 的控制权

对于这样的根本原因导致的线程安全问题我们是没有办法从根源解决的
 

## 2.多个线程修改同一个变量

 有的时候可以调整代码，来从这里入手，规避线程安全问题，但是普适性不高
 一个线程修改一个变量，没事
 多个线程读同一个变量，没事
 多个线程修改不同变量，还没事                                                   多个线程修改同一个变量，会出线程安全问题

> 把String设置为不可变对象有什么好处？（不能修改String对象的内容）
>  好处有很多，其中一个好处就是"线程安全"
>
> String 不是final修饰，而是把set系列方法给藏起来了（private)

 代码案例：

```java
public class Thread5_2 {
    private static int count = 0 ;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for(int i = 0 ; i < 50000 ;i ++){
                count++;
            }
        });
        Thread t2 = new Thread(()->{
            for(int i = 0 ; i < 50000 ; i++){
                count++;
            }
        });
        t1.start();
        t2.start();
        t1.join();
        //让 t1 join之后等t1线程执行完，t2 再 join 
        t2.join();
        System.out.println("count = " + count);
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

输出结果：

![img](https://img-blog.csdnimg.cn/a885559eff494c44a6a052278314c480.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



 数次尝试之后，会发现count结果并不是想象中的 100000



网络上很多博客认为最终的结果会处于50000到100000之间，但如果CPU执行操作如下的话，则结果会少于50000

![img](https://img-blog.csdnimg.cn/34b0c673bd244819898aa585bd70ef4a.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

> t1线程                              t2线程
>
> 将数据 0 存储到寄存器                
>
> ​                                   两次完整的指令操作使内存中存储的数据变为 2 
>
> 将寄存器中的0变为1
>
> 将寄存器中的1存储到内存当中

当这种情况多出现几次之后，t2线程的操作相当于被无效化了，所以结果就会出现小于50000的情况

如果看不懂上述操作的化，可以看完下面的 **原子性** 再回来看这段内容



那为什么会出现结果不是100000这样的问题？

**原因之一**因为count++的操作不是原子性的，会导致两个线程在修改同一个变量的时候出现线程安全问题，导致数据出错，**原因之二**因为两个线程同时进行了，要解决这个问题，可以在 t1 线程join()之后，等待t1执行完，t2再join()并执行，这样使两个线程错开执行也能解决问题，但是不能体现出多线程的高效性，降低了程序的效率。

## 3. 修改操作不是原子性的

铁块由一个个肉眼不可见的铁原子组成

原子性的“原子”表示不可分割的最小单位

CPU执行操作，都是以“一个指令”为单位进行执行的，一个个指令就像铁原子一样组成了铁块，完成CPU的执行操作

解决线程安全问题，最常见的办法，就是从这里入手，把多个操作通过特殊手段，打包成一个原子操作！

像上述代码的 count++ 操作，本质上是三个CPU操作

> 1）把内存的数据读取到 CPU 寄存器中（load)
>
> 2) 把 CPU 的寄存器中的值，进行 +1 (add)
>
> 3) 把寄存器中的值，写回到内存中（save)

由于当前是两个线程修改一个变量，由于每次修改是三个步骤（不是原子的），由于线程之间的调度顺序不确定

所以两个线程在真正执行这些操作的时候，就有可能有多种执行的排列顺序

![img](https://img-blog.csdnimg.cn/f473942e28734d56af037d275c008000.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 这两种执行的排列方式不会出现问题，其他的排列方式都会有问题

例如：

![img](https://img-blog.csdnimg.cn/b1d9bf88335e46fdb3b5a9ee697b0f08.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 **解决办法：使用synchronized关键字来加锁，让 count++ 变成原子性操作**

## synchronized关键字

### 1、synchronized 关键字的作用

> 上厕所进了坑之后，这个坑就是你自己用了
>  把门一锁，这个时候别人就进不来了
>  用完了，然后出来，把锁打开，解锁
>  在加锁，解锁两个操作之间，都是独占这个坑的，别人无法使用

解决上述线程不安全问题，也是类似。
 在 count++ 之前先加锁，在 count++ 之后，再解锁
 在加锁和解锁之间，进行修改，这个时候，别的线程想要修改，不好意思，修改不了（别等线程只能阻塞等待，阻塞等待的线程状态，BLOCKED状态）

> 某个男生，追个妹子
>  如果这个妹子，比较招风
>  可能就有多个男生在同时追这个妹子
>  如果某个男生追到了，就会发个朋友圈，官宣
>  官宣就是加锁了，这个男生就独占了这个妹子
>  其他男生也想追，就只能阻塞等待，等待到这个男生分手了（释放锁，解锁），才有解锁

```java
Java代码中，进行加锁，使用 synchronized 关键字
使用synchronized关键字修饰普通方法

public synchronized void increase(){
    count++;
}

当进入方法的时候，就会加锁
方法执行完毕，自然解锁
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

两个男生追同一个女生，A追到了，B就要阻塞等待（锁发生了竞争）
 如果是两个男生分别追两个女生呢，A追到了女生1，是否影响B追女生2？（这种A和B的行动是互不干扰的，不存在锁竞争）

当执行一个线程中被加锁的操作时，CPU并不是一鼓作气就执行完这个操作，中间也有可能会有调度切换的，即使 t1 切换走了， t2 仍然是 BLOCKED 状态，无法在 CPU 上运行的

> 类似于图书馆占座
>
> 当你去图书馆学习，发现这个位置已经有人坐了，你想坐在这里，就得阻塞等待
>
> 而坐在这的人，不一定一直在学习，有可能学了一会，除去干其他事了，但是他的书还在这里（线程调度出CPU，但是锁没有释放，这个时候还是无法占用这个位置）

本来线程调度，是随机的过程。一旦两组 load add save 交织在一起，就会产生线程安全问题。现在使用锁，就使这两组 load add save 能够并行执行了。加锁把这个程序由并发变成了并行，会降低程序的执行效率，但我们要明确一点，**使用多线程确实是为了提高效率，但是前提是你得算的对。**



加锁要考虑好锁哪段代码

锁的代码范围不同，对代码的执行效果会有很大的影响。锁的代码越多，就叫做 ”锁的粒度越大、越粗;锁的代码越少，就叫做“锁的粒度越小/越细”。

```java
public class Thread5_3 {
    private static Counter counter = new Counter();
    public static void main(String[] args) throws InterruptedException {
        long beg = System.currentTimeMillis();
        long a = 0;
        Thread t1 = new Thread(()->{
                for(int i = 0 ; i < 50000 ; i++) {
                counter.increase();
                }
        });
        Thread t2 = new Thread(()->{
                for(int i = 0 ; i < 50000 ; i++) {
                counter.increase();
                }
        });
        t1.start();
        t2.start();

        t1.join();
        t2.join();
        long end = System.currentTimeMillis();
        System.out.println("执行的时间间隔：" + (end - beg) + "ms");
        System.out.println(counter.count);
    }
}
class Counter {
    public int count = 0;
    public synchronized void increase(){
        
            count++;
        
    }

}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

只锁 count++ 的输出结果：

![img](https://img-blog.csdnimg.cn/da26e5b899884c95bd99d9bea2203a66.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 如果把 for循环 和 count++ 一起锁起来

```java
class Counter {
    public int count = 0;
    public synchronized void increase(){
        for(int i = 0 ; i < 50000 ; i++){
            count++;
        }
    }

}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

 输出结果：

![img](https://img-blog.csdnimg.cn/881f01cd12b24cb99d6044e4f1de921b.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

第一种方法运行时间明显比第二种方法来的短，因为当不锁 for 循环的时候，两个 for 循环并行执行，比两个for循环并发执行效率来的高。increase()方法里面涉及到锁竞争，方法里面的代码是并行执行的，但是 for 循环在锁外面，两个 for 循环仍然是 并发 的。如果把 for 循环也写到加锁的代码里面，这个时候就和并行执行完全一样了。



要加锁的代码，不在一个方法里面，怎么办？

还有别的办法。

来看看 synchronized 的用法

> **1.修饰方法**
>
> 
>
> **修饰普通方法的时候，锁对象相当于 this**
>
> **修饰静态方法的时候，锁对象相当于 类对象（不是锁整个类）**
>
> 
>
> **2.修饰代码块**  
>
> 
>
> **可以把要加锁的逻辑代码放到 synchronized 修饰的代码块之中，也能起到加锁的效果**
>
> **锁对象在（）指定**



要加锁的代码不一定就得是个方法，如果一个方法中有些代码需要加锁，有些不需要，就可以使用这种修饰代码块的方式进行了！

```java
synchronized(){
    count++;
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

 （） 里面填的东西就是你要针对哪个对象加锁（被用来加锁的对象，就简称为“锁对象”）

```java
synchronized(this){
    count++;
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

 针对当前对象加锁，谁调用了 increase 方法，谁就是 this

```java
public Object locker = new Object();
public void increase(){
    synchronized(locker){
        count++;
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

任何对象都可以在 synchronized 里面作为锁对象

写多线程代码的时候，不关心这个锁对象究竟是谁，是哪种形态

只是关心，两个线程是否锁同一个对象，锁同一个对象就有竞争，锁不同的对象就无竞争



### 2、锁的可重入性

> 一个人上厕所的时候，把门锁了
>
> 锁了之后，从窗户出去了
>
> 过一会又有人来上厕所，发现厕所门锁着
>
> 但是实际上里面没有人
>
> 
>
> 此时在门口等，永远也等不到里面的人把锁打开
>
> 外面的人的等待就会一直持续下去
>
> 
>
> 这就是死锁

一个线程，连续针对一把锁，加锁两次，就可能造成死锁

```java
    public synchronized void increase(){   //实例方法
        synchronized (this){
            //.....
        }
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

形如上述代码，一个线程针对一把锁，连续加锁两次

第一次加锁，能够加锁成功

第二次加锁，就会加锁失败（ 调用increase()方法的对象已经被占用 ）

此时就会在第二把锁这里阻塞等待，等到第一把锁被解锁，第二次加锁才能成功

第一把锁解锁，则要求执行完 synchronized 代码块，也就是要求第二把锁能够加锁成功



针对上述情况，不会产生死锁的话，这样的锁就叫做“**可重入锁**”

会产生死锁，这个锁就叫做“**不可重入锁**”



可重入锁的底层实现，是很简单的

只要让锁里面记录好，是哪个线程持有的这把锁

t 线程尝试针对 this 来加锁，this 这个锁里面就记录了 是 t 线程持有了它

第二次进行加锁的时候，锁一看，还是 t 线程，就直接解锁了，没有任何负面影响，不会阻塞等待

> 追妹子，向妹子表白：啊，妹子，我爱你！
>
> 如果妹子羞答答地说：嗯嗯~~（加锁成功）
>
> ​                  你是一个好人（加锁失败）
>
> 如果你已经加锁成功了，你已经和妹子在交往了
>
> 交往过程中，你又给妹子说，啊，妹子，我爱你~这个时候妹子会说，你是个好人吗？

```java
    synchronized(this){  // 真加锁

        synchronized (this){ // 直接放行

            //.....

        } // 第一次解锁 执行到这行代码，要不要真解锁呢？

    }// 第二次解锁
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

如何避免第一次解锁的时候就直接解锁了，导致出现第一次加锁失效

系统引入一个计数器

每次加锁，计数器++

每次解锁，计数器- -

如果计数器为 0 ，此时的加锁操作才真加锁

如果计数器为 0 ，此时的解锁操作才真解锁

> 可重入锁的实现要点：
>
> 1.让锁里持有线程对象，记录是谁加了锁
>
> 2.维护一个计数器，用来衡量啥时候是真加锁，啥时候是真解锁，啥时候是直接放行



如果计数器没有减到 0 , 程序抛出异常了，这个锁还被占用着，是不是也会死锁呢？

程序抛出异常，如果没人 catch , 就脱离了之前的代码块，脱离一层代码块，计数器就 - 1

脱离多层代码块，知道计数器减到 0 了，也就解锁了

加锁代码中出现异常，是不会死锁，无论如何解锁代码都能执行到

这是一个非常优秀的设计，也是把 synchronized 设计成一个关键字的原因

## 4.内存可见性问题

内存可见性问题本质上：因为编译器的优化，导致在多线程环境下出现的误判



例如： 一个线程负责读数据（load)，另一个线程负责修改数据(save)

假设，读数据操作非常频繁

```java
        Thread t1 = new Thread(()->{
            while(Counter2.counter == 0 ){

            }
            System.out.println("t1 执行结束");
        });
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> counter2.counter == 0 
>
> 这个操作，系统会先读取内存中的值到CPU寄存器当中（LOAD），比较寄存器中的值是否为 0（CMP）

这个while循环会运行的非常快，频繁进行多次 LOAD 和 CMP

> 因为 LOAD 消耗的时间长，比 CMP 慢 3-4 个数量级
>
> 所以编译器就想办法偷懒了，既然频繁执行 LOAD ，并且 LOAD 的结果还是一样的，干脆就执行一次 LOAD 就行了，后续进行 CMP 就不重新读内存了，效率提升很多



如果此时有另外一个线程 t2 ，把内存中 counter 的值给改了呢？

```java
import java.util.Scanner;
public class Thread5_5 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            while(Counter2.counter == 0 ){

            }
            System.out.println("t1 执行结束");
        });
        Thread t2 = new Thread(()->{
            System.out.println("请输入一个 int ： ");
            Scanner sc = new Scanner(System.in);
            Counter2.counter = sc.nextInt();
        });
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(Counter2.counter);
    }
}
class Counter2 {
    public static int counter = 0;
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

t2 线程修改内存对于对于 t1 读内存的操作不会有影响，因为 t1 已经被优化成了不再循环读内存了（t1 只读一次内存且在 t2 修改内存之前就读取完了）

（关于结果的文字还没写完）



t2 把内存改了，t1 没看到。 这就是内存可见性问题。

既然编译器自己的判定不准了，把不该优化的给优化了，就可以让程序员显式地提醒编译器，这个地方不该优化，这就是接下来 volatile 关键字的作用！

## volatile 关键字

> 上文中我们提到内存可见性，即在编译器优化的背景下，一个线程把内存给改了，另一个线程并不能及时的感知到
>
> 解决方案：避免让编译器做出“不都内存”的优化，我们要明确优化的目的是为了算的快，算的快的前提是得算的准。
>
> 此时我们可以用 volatile 这个关键字来修饰一个变量，被修饰的变量，编译器就不会做出“不读内存，只读寄存器”这样的优化！

```java
volatile public int count = 0;
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**volatile 关键字的作用：禁止了编译器优化，避免了直接读取CPU寄存器中缓存的数据，而是每次都重新读内存。**



在面试中，一旦提到了 volatile , 多半是脱离不了JMM。（Java Memory Model java内存模型）

我们引入一些新的术语，将 CPU寄存器 称为 工作内存（work memory) 即工作储存区，CPU寄存器+缓存的抽象的表述

内存 称为 主内存（main memory) 即主储存区

（此处 工作内存 并不是真的内存， 主内存 才是真的内存）



站在JMM的角度来看待 volatile :

正常程序执行的过程中，会把主内存的数据，先加载到工作内存中，再进行计算处理

编译器优化可能会导致不是每次都真的能读取主内存，而是直接取工作内存中的缓存数据。（这就可能会导致内存可见性问题）

volatile 关键字起到的效果，就是保证每次读取内存都是真的从主内存重新读取。



# 1.wait 和 notify

> 线程很讨厌的一点，就是抢占式执行，虽然线程调度的过程是随机的，但是很多时候，我们希望多个线程按照一个预期的顺序来执行

**wait notify 就是用来调配线程执行顺序的**

> 像 “ 传球 - 扣篮 ” 这一系列动作，得先传球，再扣篮
>
> 扣篮的人，就需要先 wait ，等到球传过来才能扣篮
>
> 线程执行到 wait ，就会发生阻塞
>
> 
>
> 传球的人，把球传过去，执行了 notify ，扣篮的人才会有接下去的动作
>
> 直到另一个线程，调用 notify 把这个 wait 唤醒，程序才会继续往下执行

```java
Object object = new Object();
object.wait();
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

wait 是 Object 的方法

Object 作为 Java 所有类的祖宗

因此就可以使用任意的类的实例，都能调用 wait 方法



```java
public class Thread_wait {
    public static void main(String[] args) {
        Object object = new Object();
        System.out.println("wait 之前");
        try {
            object.wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("wait 之后");
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

运行 wait() 的结果：

![img](https://img-blog.csdnimg.cn/b8af92fb3c524c45a3bf4dda23bc8bdc.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

非法的锁状态异常：说明 加锁 和 解锁 的状态出现问题

Monitor(监视器）此处特指的是 synchronized,synchronized 在 JVM 中也叫做 “ 监视器锁 ” 



其实 wait 操作， 内部本质上，做了三件事

1.释放当前锁

2.进行等待通知（等待别人把球传过来）

3.满足一定条件的时候（别人调用 notify)，被唤醒，然后尝试重新获取锁



等待通知的前提，是要先释放锁，而释放锁的前提，是你得加了锁，加上了锁，才能谈释放



为啥是要先释放锁，才等待通知呢？

![img](https://img-blog.csdnimg.cn/8e537b9e413f4d50b9ec904cf7a33790.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

> 滑稽老铁来取钱，就要先进入ATM，加锁，然后执行取钱操作
>
> 
>
> 此时滑稽老铁发现，ATM里面没钱了（不是卡上没钱，是ATM里面没钱了）
>
> 
>
> 等一会，运钞车把钱运过来了
>
> 
>
> 滑稽老铁，是在ATM里面等，还是ATM外面等合适？
>
> 肯定是外面

 ![img](https://img-blog.csdnimg.cn/7f048296e5af4059b6084c03edbd34c1.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑：“ATM里面这小子还不出来，我怎么把钱放进去？？”

> 如果里面的滑稽不出来（出来要解锁）
>
> 这个时候拎着钱来的工作人员
>
> 也进不去，也没法把钱放到ATM里面

 要把 ATM 的操作空间给其他人，因此 wait 的第一步操作，就是先释放锁，保证其他线程能够正常往下进行

![img](https://img-blog.csdnimg.cn/83a7bd91aee6498c931f4c6e063f8432.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

因为即使 ATM 没钱，也不耽误这些老哥的操作

所以取钱的滑稽老铁就别一直占着 ATM 不放了，选择 wait 一下，然后把锁打开，让其他滑稽老铁操作。

wait 可以简单理解成，如果当前代码执行的时机还不成熟，就 wait（得结合具体的业务逻辑来看待）

 ![img](https://img-blog.csdnimg.cn/1f74497584e84eb2ae9e03c2e1ca9ef6.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



 要保证业务员存钱的ATM是我要取钱的ATM，即要保证，加锁的对象，和调用wait的对象是同一个对象，还要保证，调用 wait 的对象和调用 notify 的对象，也是同一个对象

```java
        Object object = new Object();
        synchronized (object) {
            try {
                object.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



Java 中除了有一个 notify 之外，还有一个 notifyAll

> 多个线程都在 wait 
>
> notify 是随机唤醒一个
>
> notifyAll则是全部唤醒 ( 就像业务员存完钱之后，拿喇叭说有要取钱的都可以来排队了）
>
> 即使唤醒了所有的wait,这些wait也需要重新竞争锁，重新竞争锁的过程仍然是并行的，一个人用完锁之后，另一个人再用



**wait 和 sleep 的对比（面试题）**

都是让线程进入阻塞等待的状态

> sleep 是通过时间来控制何时唤醒的
>
> wait 则是由其他线程通过 notify 来唤醒的



# 多线程案例

## 1.单例模式

​     单例模式是一种常见的设计模式

​     设计模式则是一些大佬根据一些常见的需求场景，整理出来了一些应对的解决方案，供其他人来学习和研究

​    类似于棋谱，普通人按照棋谱来下棋，就不会下的太差，提高了棋手的“下线”

> ​    单例模式，从字面意思来理解就是 单个实例 instance(对象）
>
> 
>
>  某个类，有且只有一个实例
>
> 一个类只有一个实例是需求决定的，有些需求场景，就要求实例不能有多个（比如说一个人就只能有一个老婆）通过单例模式，相当于对“单个实例” ， 做了一个更加严格的约束

**单例模式，本质上就是借助 编程语言 自身的语法特性，强制限制某个类，不能创建多个实例**



如何使用 Java 的语法特性来实现这个功能呢？

首先我们想象一下，Java中是否有哪个东西天然就是单个实例的呢？—— static

static 修饰的成员/属性 变成了 类成员/类属性

其实当属性变成类属性的时候，此时就已经是“单个实例”



接下来我们用 Singleton 这个类来展示一下如何把一个类变成单例类：

```java
public class Thread_singleton1 {
    public static void main(String[] args) {
        // 代码如果这么写，就违背初衷，就应该禁止这个类在类外部被new
        Singleton instance2 = new Singleton();
    }
}
// 这个类就作为一个“单例类”
// 要求 Singleton 只有一个实例
class Singleton{
    // private 修饰的变量只能在本类中访问
    private static Singleton instance = new Singleton(); // 创建出 Singleton 这个类的唯一实例

    // 此处就约定，类外部使用 Singleton 的实例，就使用 getInstance 方法，就拿到了
    public static Singleton getInstance(){
        return instance;
    }

    // 把 构造方法 设为 private , 此时在类的外面，就无法继续 new 实例了
    private Singleton(){

    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

如果我们要继续使用这个唯一实例的话，唯一的入口就是通过 getInstance 方法

```java
Singleton instance = Singleton.getInstance();
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

此时也就强制保证了当前的 Singleton 是 “ 单例 ” 了



上述代码里写的实现单例模式的方法，叫做 **“ 饿汉模式 ”**

因为 Singleton 类创建的实例是有 static 修饰的，所以是在类加载的时候创建的

创建实例的时机非常早，非常急迫



还有另外一种典型的实现单例模式的方式，叫做 **“ 懒汉模式 ”**

**创建实例的时机更迟，带来了一个更高的效率**

懒汉模式把 耗费精力的操作延后，避免做菜又要刷碗的情况

```java
class SingletonLazy{
    private static SingletonLazy instance = null;
    public static SingletonLazy getInstance(){
        if(instance == null){
            instance = new SingletonLazy();
        }
        return instance;
    }
    private SingletonLazy(){};
}
public class Thread_singleton2 {
    public static void main(String[] args) {
        SingletonLazy instance = SingletonLazy.getInstance();
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

if 语句使得如果后续整个代码没有人调用 getInstance, 这样就把构造实例的过程给节省下来了
 或者即使有代码后续调用 getInstance， 但是调用的时机比较晚，这个时候，创建实例的时机也就迟了，就和其他的耗时操作错峰了（一般程序刚启动的时候，要初始化的东西很多，系统资源紧张）

> 为什么 懒汉模式 效率更高？
>
> 我们可以用洗碗的案例来理解：
>
> 案例一：懒汉模式 ——不迫切，用到碗再说洗碗的事
>
>  假设一顿饭使用了四个碗，这四个碗都不会立即洗，先放一边，下顿饭需要用碗了的时候再洗
>
> 案例二：饿汉模式——非常迫切，立马洗碗
>
> 假设一顿饭使用了四个碗，就会立即洗这四个碗，不会留到下次要用再说，而下一顿饭可能只用了两个碗，这个时候只要洗两个碗就可以了，洗的碗少了，不会因为上次剩很多碗而浪费煮饭时间



**接下来到了重点，既然我们本章的内容学习的是多线程，那么我们必然要关注的一点就是，上述写的懒汉和饿汉两种模式的代码，哪个线程安全，哪个线程不安全呢？为什么？**

我们先看一下两个模式代码的差异

饿汉模式：操作只是单纯的“读数据”，不涉及到修改

```java
public static Singleton getInstance(){
        return instance;
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

懒汉模式：操作不仅涉及到读，也涉及到修改，就会不安全

```java
public static SingletonLazy getInstance(){
        if(instance == null){
            instance = new SingletonLazy();
        }
        return instance;
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

让我们来看一下，懒汉模式为什么会不安全？

![img](https://img-blog.csdnimg.cn/586a0642ce3b4a9e9566577aec812d9e.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

当 t2 线程进行 LOAD 的时候

t1 线程还没进行 NEW 和 ASSGIN（赋值） ，值还没有被修改

t2 LOAD 和 CMP 的时候，读到的还是旧的值，此时 t2 仍然能够进入到 new 操作，此时就会导致实例被创建出多份了。



如何修改上述代码，保证懒汉模式，是线程安全的呢？

加锁，把多个操作打包成一个原子操作。

此处想要达到的效果是 t2 读到的是 t1 修改之后的值

得让 t2 的 LOAD 在 t1 执行完 NEW 之后再执行

```java
public static SingletonLazy getInstance(){
    synchronized(SingletonLazy.class){
        if(instance == null){
            instance = new SingletonLazy();
            }
        }
        return instance;
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

通过这种加锁方式，解决了线程安全问题，但是又引入了新的问题

线程不安全，也不是一直都不安全，只是创建出实例之前（首轮调用的时候）才会触发线程不安全问题

一旦实例创建好了，此时线程也就安全了

上述加锁代码的写法，导致当后续线程已经安全的时候，仍然还得加锁 

> 加锁绝对不是“无脑加”
>
> 需要的时候加，不需要就不加
>
> Vector,StringBuffer,HashTable为什么不推荐使用呢？因为这些东西就在无脑加锁
>
> 而且，加锁的开销其实还是比较大的（加锁可能会涉及到 用户态 ->内核态 之间的切换，这样切换成本是比较高的）



**如何让这个代码，需要加的时候才加，不需要加时候不加呢？**

实例没有创建之前，线程是不安全的，需要加

实例创建之后，线程是安全的，就不需要加

因此就可以在加锁的外层，再加上一层判定

```java
public static SingletonLazy getInstance(){
    if(instance == null){
        synchronized(SingletonLazy.class){
            if(instance == null){
                instance = new SingletonLazy();
                }
            }
    }
        return instance;
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> 第一个 if 的作用,是为了在创建实例之后不用每次判断是否创建实例都要加锁 （判断是否要加锁），主要是为了创建实例之后增加程序效率考虑，如果创建过实例就不用加，没创建过实例为了线程安全就要加。
>
> 第二个 if 的作用，是在锁成功加上之后，再判断是否要创建实例，这个 if 是为了创建实例考虑的

**两个 if 语句看上去一模一样，为什么要写两遍呢？**

这两个 if 语句中间隔着一个 加锁 操作， 这就意味着这两个 if 执行的时间间隔， 很可能非常久

因为加锁就可能产生竞争，竞争就会导致阻塞，阻塞的话，什么时候能唤醒就不一定了  

因此，第二个 if 的结果 和 第一个 if 的结果可能是截然不同的，第一个 if 成立了， 第二个 if 不一定成立。如果中间没有隔着synchronized，那么第一个 if 成立，大概率第二个 if 也成立。



**上述的代码，其实还有一个重要的问题！**

假设两个线程同时调用 getInstance

第一个线程拿到锁了，进入第二层 if ,开始 NEW 对象

因为 **NEW 操作本质上也是分成三个步骤**的（粗略分的步骤，其实内部有很多细节）

> \1. 申请内存，得到内存首地址
>
> \2. 调用构造方法，来初始化实例
>
> \3. 把内存的首地址赋值给 instance  引用                                

所以这个场景下，编译器可能会进行“指令重排序”的优化，在单线程的角度下，2 和 3 是可以调换顺序的（单线程条件下， 2 和 3 谁先执行谁效果都是一样的） 



假设此处触发了指令重排序，并且 t1 按照 1 3 2 的顺序执行的

有可能 t1 执行了 1 和 3 之后，执行了 2 之前 , t2 线程调用了个 getInstance , getInstance 会认为 Instance 非空，就直接返回 Instance ，并且在后续可能就会针对 instance 进行解引用操作（使用里面的属性/方法），但是这样得到的是不完全的对象，只是有内存，内存上面的数据无效。



**我们只要在变量前加上 volatile 就能避免指令重排序的问题，也能保证内存可见性**

```
private volatile static SingletonLazy instance = null;
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

# 

# 阻塞队列

## 1.生产消费者模型

阻塞队列是一个线程安全的，带有阻塞功能的队列

> a) 如果队伍满了，继续执行入队列的话，入队列操作就会阻塞，直到队列不满，入队列才能完成
>
> b) 如果队伍空了，继续执行出队列的话，出队列操作就会阻塞，直到队列不空，出队列才能完成

阻塞队列的应用场景：生产消费者模型——一种描述多线程协同工作的方式

![img](https://img-blog.csdnimg.cn/283fd96bd5554d818223ea71264377fa.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



> 以包饺子为例，有两种不同的包饺子模型：
>
> 1.三个人围着一个桌子包饺子，每个人都擀一个饺子皮，然后再包一个，重复这个动作
>
> 这个模型会有一个严重的问题，三个人会频繁竞争“擀面杖”导致严重的锁冲突
>
> 2.一个人专门擀饺子皮，另外两个人负责包饺子（常见的模型）
>
> 在这个模型中，擀皮的人是生产者，另外两个是消费者，放饺子皮的地方就是“交易场所”

第二个模型，除了很好地解决了锁冲突的问题，还有其他的优势

### 优势1： 使用阻塞队列，有利于代码“解耦合”

> 耦合：两个模块之间的关联关系，关系越紧密，耦合越高，关系越不紧密，耦合越低

![img](https://img-blog.csdnimg.cn/e335d4dc42614005945fb608d2a27054.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

###  优势2：削峰填谷

如果没有生产者消费者模型的写法，外面流量过来的压力就会直接压倒在每个服务器上，如果某个服务器抗压能力不太行，就容易挂

> 如果使用阻塞队列，此时当流量骤增的时候，A 和 队列 承受了压力
>
> B 和 C 还是按照原来的节奏来消费数据，对 B C 的冲击就不大
>
> 
>
> 为啥一个服务器同一时刻接收很多的请求就容易挂呢？
>
> 因为服务器每处理一个请求，都是需要消耗一定的硬件资源的（包括但不限于 CPU ， 内存， 硬盘...)同一时刻请求越多，消耗的资源就越多，一台主机的硬件资源是有限的，一旦某个硬件资源耗尽了，此时服务器就挂了。（所谓的分布式系统，本质上就是加入了更多的硬件资源）

就类似于三峡水库的作用

![img](https://img-blog.csdnimg.cn/e356ccdcfa414e73bd8d7cac30273d1f.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



### 阻塞队列的具体使用

1.标准库的阻塞队列

```
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;

public class Thread_BlockingQueue {
    public static void main(String[] args) {
        // 指定队列最大长度
        BlockingQueue<Integer> blockingQueue = new LinkedBlockingDeque<>(100);
        // 队列一般都有三个基本操作：入队列，出队列，取队首元素
        // blockingQueue.offer();
        // 带有阻塞功能，offer不带
        // 入队列 
        blockingQueue.put(1);
        blockingQueue.put(2);
        blockingQueue.put(3);
        // 出队列 
        Integer ret = blockingQueue.take();
        System.out.println(ret);
        ret = blockingQueue.take();
        System.out.println(ret);
        ret = blockingQueue.take();
        System.out.println(ret);
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

2.自己实现一个阻塞队列（**通过这个来强化对多线程的理解**）

> 如何自己实现一个阻塞队列呢？
>
> \1. 先实现一个普通队列（两个版本，基于链表或基于数组）
>
> \2. 加上线程安全
>
> \3. 加上阻塞的实现

阻塞队列是基于循环队列来实现的，让我先来看看什么是阻塞队列：

当队列是空队列时,head 和 tail 处于同一个位置

![img](https://img-blog.csdnimg.cn/17ce63b8fbc04a9b8a0abef30f65ccd2.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 存入一个元素之后，tail 往后移动一位

![img](https://img-blog.csdnimg.cn/e699b7a518674ae08ae3460375146835.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

存入两个元素之后，去除第一个元素,head 往后移动一位

![img](https://img-blog.csdnimg.cn/ee584b95cd2e436aa1f1019a2dabe5ad.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



当队列末尾满了之后,tail 回到队列开始

![img](https://img-blog.csdnimg.cn/35fd4d96450041b998a08a70c06b0149.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



 [head,tail) 表示了队列中的有效元素的范围

当 tai 和 head 重合在一起的时候，如何区分队列是 “空” 还是 “满”

按照上述设定，队列空还是满都是指针重合，无法区分（此时可以浪费一个数组空间，多加一个变量记录个数）

![img](https://img-blog.csdnimg.cn/11ab8196e6124b1c89cc366af01c6dee.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



了解循环队列之后，我们自己来实现阻塞队列

```java
public class Thread_BlockingQueue2 {
}
class MyBlockingQueue{
    private int[] items = new int[1000];
    // 防止内存可见性问题
    private volatile int head = 0;
    private volatile int tail = 0;
    private volatile int size = 0;

    // 入队列
    public void put(int elem) throws InterruptedException {
        // 因为涉及修改操作，防止多线程调用出现安全问题，要加锁
        synchronized (this) {
            // 判定队列是否满了，满了则不能插入
            while(size >= items.length) {
                this.wait();
            }
            // 进行插入操作，把 elem 放到 items 里， 放到 tail 指向的位置
            items[tail] = elem;
            // 放完之后, tail 往后移动一位
            tail++;
            // 如果tail超出末尾，则回到开头位置
            if (tail >= items.length) {
                tail = 0;
            }
            // tail = tail % items.length;
            // 不建议使用这个操作，因为这个代码不直观，运行速度也没有优势
            size++；
            this.notify();
        }
    }

    // 出队列，返回删除的元素内容
    // public int take(){  因为 int 不容易表示无效值（null）,所以把返回值改为 Integer
       public Integer take() throws InterruptedException {
        synchronized (this){
            // 判断队列是否空，如果空了，则不能出队列
            while(size == 0){
                this.wait();
            }
            // 进行取元素操作
            int ret = items[head];
            head++;
            if(head >= items.length){
                head = 0;
            }
            // 当减 size-1 次的时候，head来到最后一个位置
            // 所以这次执行完 size-- 之后，size = 0,head需要回到组开始位置
            size--;
            this.notify();
            return ret;
        }
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> 注意：在队列中，同一个队列，同一时刻，不会出现即是空又是满的状态， put() 和 take() 都有加锁，且锁对象都是this，两者之一阻塞了，另一方都不会阻塞。

让我们来看代码中的一段操作

```java
            // 判断队列是否空，如果空了，则不能出队列
            // if(size == 0){
            while(size == 0){
                this.wait();
            }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

当发现队列为空，就阻塞等待，take() 就进入 wait 状态，具体什么时候唤醒，不确定，当wait（）被唤醒( notify() 或者 interrupt() )，此队列也无法确定是否非空了，因为当其他线程调用 notify() 之后 ，此线程是重新排队等待执行，而不是立马执行。while能保证在wait()方法被唤醒之后，再进行条件验证，如果还是为零，则继续进入wait()，这是双重 if 语句所达不到的。

正是因为当线程被唤醒之后是重新排队，可能会出现当一个线程wait()被唤醒之后，虽然有线程存入数据，但是被其他线程提前取走了，造成了队列中还是没有数据的情况

用一副图就可以很好解释这个现象

![img](https://img-blog.csdnimg.cn/db85d86bf8c949ac80f8705d92f00b76.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑





## 2.定时器

代码中的定时器，通常都是设定“多长时间之后，执行某个动作”



服务器开发中，客户端请求服务器

客户端发送请求之后，就需要等待服务器的响应

服务器如果没有响应，客户端不能一直死等下去，如果一直死等，很可能程序就卡死了

因此客户端经常会设置一个“超时时间”这里就可以使用定时器来实现你



我们先来看看标准库里的定时器

![img](https://img-blog.csdnimg.cn/cc2572eff8c940cfacd2c8a206b0a393.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

> TimerTask task : 即要安排的任务，一个 Runnable , 我们要做的就是继承 TimerTask ，然后重写 run 方法，从而指定要执行的任务
>
> long delay: 多长时间之后来执行 经过 delay ms 之后，执行 task 任务

一个定时器可以同时安排多个任务

```java
import java.util.Timer;
import java.util.TimerTask;

public class Thread_StandardTimer {
    public static void main(String[] args) {
        // 标准库的定时器
        Timer timer = new Timer();
        timer.schedule(new TimerTask(){
            public void run(){
                System.out.println("时间到1，快起床");
            }
        },3000);
        timer.schedule(new TimerTask(){
            public void run(){
                System.out.println("时间到2，快起床");
            }
        },3000);
        timer.schedule(new TimerTask(){
            public void run(){
                System.out.println("时间到3，快起床");
            }
        },3000);

        System.out.println("开始计时！");// 程序立即输出
    }
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

执行结果：

![img](https://img-blog.csdnimg.cn/370e95fbc4604f5caf552ecee9764013.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



 **执行完上述任务之后，进程没有退出**

Timer 内部需要一组线程来执行注册的任务

而这里的线程是 前台线程，会影响进程退出

> 前台线程会影响进程退出
>
> 后台线程（isDaemon 守护线程）不会影响进程退出，进程退出，线程就销毁



接下来我们来自己动手实现一个定时器，感受其中多线程的使用

第一步：因为schedule 第一个参数是一个任务，所以我们的代码需要能够描述这个任务

任务包含两个方面的信息，一个是要执行什么工作，另一个是要什么时候执行

第二步：如何让 MyTimer 像 timer 一样管理多个任务

> 直接拿一个ArrayList行不行？
>
> | 1000 | 2000 | 3000 | 500 | 700 |
>
> 显然用 ArrayList 的话，元素没有顺序，就不方便找到时间最小的任务

所以我们要使用优先级队列，因为优先级队列无论按照什么顺序插入，出队列的顺序都是固定的

```java
private PriorityQueue<MyTask> queue = new PriorityQueue<>();
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

这个队列不是线程安全的，而 schedule 是有可能在多线程中调用的

所以我们使用 BlockingQueue 来实现，既满足优先级队列，又满足线程安全

第三步：任务已经被安排到优先级阻塞队列中了，接下来就需要从队列中取元素了，创建一个单独的扫描线程，让这个线程不停地来检查队首元素，看看时间是否到了，如果时间到了，就执行该任务。

> 由于阻塞队列，无法 阻塞地 取队首元素（插入队列可以阻塞，取出队列可以阻塞，无法阻塞取队首元素）
>
> 因此就需要先取出任务，然后才能够判定任务时间是否到了
>
> 如果任务时间没到，还得把任务给塞回去

![img](https://img-blog.csdnimg.cn/0309309484be41dc983bfc90c13325d8.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

 第四步：运行程序发现代码中出现异常

![img](https://img-blog.csdnimg.cn/68817eee8dc1498c89db9a4674476d20.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



 **MyTask cannot be cast（类型转换） to java.lang.Comparable（描述了两个对象的比较规则）**

因为加入队列的元素要能比较大小，才具有优先级，而当前 MyTask 不具备比较大小的能力，所以要让 MyTask 实现 Comparable 即可



第五步：定时器还有一个严重的问题

```java
Thread t = new Thread(() -> {
            while(true){
                // 取出队首元素
                try {
                    MyTask task = queue.take();
                    // 当前时间 大于等于（超出或刚好等于） 任务设定时间，就要执行任务
                    if( System.currentTimeMillis() >= task.getTime()){
                        //时间到了，该执行任务了
                        task.getRunnable().run();
                    }else{
                        // 还没到时间点,把任务再放回队列中
                        queue.put(task);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t.start();
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> 假设我 2：30 要去上课，当前时间是 12：00
>
> 当我12:00:00,拿出手机发现时间还早，放下手机
>
> 当我12:00:01,拿出手机发现时间还早，放下手机
>
> 当我12:00:02,拿出手机发现时间还早，放下手机
>
> .........
>
> while(true){ .... } 就像上述事件一样
>
> 如果按照这个方式等待，等待的过程时间都被浪费了，而且看时间对于整个任务的进程没有什么影响
>
> 因此， 这个循环就是在忙等
>
> CPU 并没有被空闲出来，这里的等待就没有意义了

sleep可以让等待不是忙等，因为无法确定sleep的时间差，就会出现如果在 sleep 的时间里，来了一个新任务，此时线程在 sleep 就会导致工作线程无法在 新任务的执行时间 按时执行

我们可以用之前提到的 wait() 和 notify() 来解决

```java
    public MyTimer(){
        // 创建一个扫描线程
        Thread t = new Thread(() -> {
            while(true){
                // 取出队首元素
                try {
                    MyTask task = queue.take();
                    // 当前时间 大于等于（超出或刚好等于） 任务设定时间，就要执行任务
                    long curTime = System.currentTimeMillis();
                    if( curTime >= task.getTime()){
                        //时间到了，该执行任务了
                        task.getRunnable().run();
                    }else{
                        // 还没到时间点,把任务再放回队列中
                        queue.put(task);
                        // 还没到时间，就等待
                        synchronized (locker){
                            locker.wait(task.getTime() - curTime);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t.start();
    }
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)