# Spring AOP 

## AOP介绍

Spring AOP（Aspect Oriented Programming，面向切面编程）是 Spring 框架的重要组成部分，用于实现横切关注点。AOP 的主要目标是将与业务逻辑分离的系统服务（例如日志、安全性、事务管理等）模块化为独立的切面以改善模块化。

```
针对某一方面编程，进行集中处理

如果没有把登录请求和其他请求分开，那么就是每次（例如查询，修改，删除博客的操作）就需要同时完成登录请求，那么如果有一天登录请求修改了一些参数，就要把所有包含登录的功能都修改一遍，导致代码耦合性太高，此时就需要将这个登录请求单独分成一个模块完成，这就是AOP

针对这种功能统一，且使用的地方较多的功能，就可以考虑使用AOP来统一处理了
```

Spring AOP 提供了一种方式可以将辅助行为（例如日志、安全等）封装到独立的模块中，这些模块可以在整个应用程序中的多个位置被重复使用。这样可以避免在每个模块中都编写这些辅助行为，从而实现代码的重用和业务逻辑的解耦。



## AOP应用场景

Spring AOP（面向切面编程）是 Spring 框架的一部分，它允许程序员将横切关注点分离到独立的模块中。以下是一些 Spring AOP 的典型使用场景：

1. **日志记录（Logging）：** 这可能是使用 AOP 的最常见场景。日志代码通常散布在业务逻辑中，导致代码混乱并难以维护。使用 AOP，可以把日志记录作为一个切面来处理，使得业务代码更加清晰。

2. **事务管理（Transaction Management）：** 在企业级应用中，事务管理是必不可少的，但是事务代码可能会散布在业务逻辑中。通过 AOP，可以将事务管理代码从业务逻辑代码中剥离出来，以提高代码的可读性和可维护性。

3. **安全检查（Security Checks）：** 可以使用 AOP 实现方法级别的安全性检查。例如，可以定义一个切面来检查用户是否有权调用某个方法。

4. **性能统计（Performance Statistics）：** AOP 可以用来收集方法的性能统计信息，例如方法的执行时间。这些信息可以帮助我们优化应用的性能。

5. **错误处理（Error Handling）：** 可以定义一个切面来处理所有的错误和异常，这样可以避免在每个方法中都写错误处理代码。

6. **缓存：** 利用 AOP 可以实现自动化的缓存处理，从而提高系统的性能。

7. **并发控制：** 利用 AOP，可以更为方便地进行并发控制，如对并发访问进行锁控制。

这些场景只是 AOP 的一部分，实际上，任何需要在多个方法或对象中共享的功能都可以被视为切面，并可以利用 AOP 进行处理。

## AOP组成

#### 概念

1. **Aspect（切面）**： 切面是跨多个类或对象的关注点（或关注的功能）。例如，日志记录就是一个典型的切面，它可能会跨越多个服务或类。 

   ```
   通俗地理解：在程序中就是处理某方面具体问题的一个类。
   这个类中有很多方法，这些方法就是切点和通知
   ```

   

2. **Joinpoint（连接点）**：在程序执行过程中明确的点，如方法的调用或特定的异常被抛出。在 Spring AOP 中，连接点总是代表方法的执行。

   ```
   所有可能会触发 AOP 的点（触发拦截规则Pointcut）
   ```

3. **Advice（通知/增强）**：切面在特定的连接点上执行的动作。Spring 切面可以使用五种类型的通知：before、after、after-returning、after-throwing 和 around。

   ```
   程序中被拦截请求触发的具体动作（做什么）就是通知中实现的具体业务代码（AOP具体的执行动作）
   ```

   ```
   a.前置通知：在执行目标方法之前执行的方法
   b.后置通知：在执行目标方法之后执行的方法
   c.异常通知：在执行目标方法出现异常时，执行的通知
   d.返回通知：目标方法执行了返回数据（return)时，执行的通知
   e.环绕通知：在目标方法执行的周期范围内（执行之前、执行中、执行后）都可以执行的方法
   ```

   Spring AOP (Aspect-Oriented Programming) 通过 advice（通知）来实现在程序的特定点切入代码。在 Spring AOP 中，有以下几种类型的 advice：

   1. **Before advice**：这种通知在连接点之前运行，但不能阻止执行流程继续（除非它抛出异常）。

   2. **After returning advice**：这种通知在连接点成功完成之后运行，例如，方法返回其结果后。

   3. **After throwing advice**：这种通知只有在方法抛出异常时才会运行。

   4. **After (finally) advice**：无论连接点退出的方式如何（正常或异常返回），这种通知都会执行。

   5. **Around advice**：这是最强大的通知类型，可以在方法调用前后自定义行为。它也是唯一能决定是否继续执行连接点或直接返回它自己的结果的通知。

   

4. **Pointcut（切点）**：用来进行主动拦截的规则（配置）

   ![image-20230515160315828](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230515160315828.png)

   ```
   切点就相当于保存了众多连接点的一个集合（如果把切点看成一个表，而连接点就是表中一条条数据）
   切入点定义了在哪些连接点应用切面，即确定在哪些地方应用哪些功能。
   例如在哪些页面需要登录功能（删除，添加博客等）
   ```

   

5. **Introduction（引入）**：添加新方法或属性到现有类中。

6. **Target object（目标对象）**：被一个或多个切面增强的对象。也被称为被代理对象。

7. **Weaving（织入）**：将切面连接到其他应用程序类型或对象上以创建一个被建议的对象。这可以在编译时、类加载时和运行时完成。

Spring AOP 默认使用运行时织入，这对于 Spring 框架的企业级 Java 开发来说是足够的。但如果需要更复杂的 AOP，例如编译时织入或更精细的控制，可以考虑使用功能更全面的 AspectJ 库。

#### 案例

1. **切面（Aspect）：** 可以想象你正在制作一部电影。这部电影中有许多角色（类），每个角色都有自己的任务（方法）。现在，你想要为电影添加音乐。这就像是一个切面，音乐会贯穿电影的各个部分，但并不改变角色的任务。

2. **连接点（Join Point）：** 在电影中，有许多地方你可以插入音乐，比如在开始，结束，或者在某个关键场景。这些你可以插入音乐的地方就像是连接点。

3. **切入点（Pointcut）：** 但是，你可能并不想在电影的每一个场景都插入音乐。你可能只想在特定的场景，比如在悲伤或者开心的场景插入音乐。这些你真正想插入音乐的地方就是切入点。

4. **增强（Advice）：** 这就是你真正插入的音乐。你可能会在开始的时候插入一段欢快的音乐（前置增强），在结束的时候插入一段宁静的音乐（后置增强），或者在角色悲伤的时候插入一段悲伤的音乐（环绕增强）。

5. **引入（Introduction）：** 假设你想在电影中添加一些新的元素，比如添加一些评论或者解说，这就是引入。它是一种特殊类型的增强，可以让你在不改变现有类的情况下，添加新的方法或属性。

6. **织入（Weaving）：** 这是将切面（音乐）添加到电影中的过程。这可以在电影制作的过程中完成（编译时织入），也可以在电影放映的时候完成（运行时织入）。

![image-20230515163721100](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230515163721100.png)

再通过一个简单的用户验证案例来理解这些概念。

首先，我们有一个用户 User，他想要访问服务器 Server 上的一些资源。为了保护资源的安全，我们需要在 User 访问资源之前对其进行身份验证。这就是我们的切面（Aspect）——身份验证。

在 User 访问 Server 的过程中，有许多地方我们都可以插入身份验证的代码，比如在 User 发送请求时，或者在 Server 接收请求时。这些都可以是连接点（Join Point）。

但是，我们并不想在每个连接点都进行身份验证，我们可能只想在 User 尝试访问受保护资源时进行验证。所以，我们的切入点（Pointcut）可能是 User 访问受保护资源的请求。

我们的增强（Advice）就是实际的身份验证代码。我们可能会在 User 发送请求之前（前置增强）检查他是否有有效的凭据。如果他没有有效的凭据，我们可能会抛出一个异常（异常增强）。

最后，我们的织入（Weaving）就是将身份验证的代码添加到 User 访问受保护资源的过程中。这通常会在应用运行时完成。

这个案例的 Spring AOP 代码可能如下：

```java
@Aspect
@Component
public class AuthenticationAspect {
    @Pointcut("execution(* com.example.server.ProtectedResource.*(..))")
    public void authenticationPointcut() {}

    @Before("authenticationPointcut()")
    public void beforeAccess(JoinPoint joinPoint) {
        User user = getUserFromContext();
        if (!isValid(user)) {
            throw new AuthenticationException("User is not authenticated");
        }
    }
}
```

以上代码定义了一个身份验证的切面，该切面在 User 尝试访问受保护资源之前进行身份验证。如果 User 没有有效的凭据，就会抛出一个异常。

## AOP实现

### 1.引入依赖

![image-20230515192323143](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230515192323143.png)

```
创建文件的时候，展示的依赖不是全部的依赖，AOP依赖不在其中，要通过 pom.xml 引入依赖
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

![image-20230515193302480](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230515193302480.png)

### 2.定义切面

![image-20230515203757319](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230515203757319.png)

### 3.定义切点

![image-20230515203834401](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230515203834401.png)

```
其中 pointcut 方法为空方法，它不需要有方法体，此方法名就是起到一个“标识”的作用，标识下面的
通知方法具体指的是哪个切点（因为切点可能有很多个）。
```



### 4.定义通知

```
在切面中定义通知
```

![image-20230515203924247](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230515203924247.png)

### 切点表达式

```
* ：匹配任意字符，只匹配一个元素（包，类，或方法，方法参数）
.. ：匹配任意字符，可以匹配多个元素 ，在表示类时，必须和 * 联合使用。
+ ：表示按照类型匹配指定类的所有类，必须跟在类名后面，如 com.cad.Car+ ,表示继承该类的
所有子类包括本身
切点表达式由切点函数组成，其中 execution() 是最常用的切点函数，用来匹配方法，语法为：
execution(<修饰符><返回类型><包.类.方法(参数)><异常>)
```

![image-20230515205014250](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230515205014250.png)