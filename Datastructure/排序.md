# 排序

## 排序的概念

### 1.排序的概念

#### 稳定性

![image-20230505100553302](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230505100553302.png)

```
两个相同的数，排序前的 前后顺序 和排序后的 前后顺序 一样，既是稳定的
```

#### 内部排序

```
全部元素都放在内存中排序
```

#### 外部排序

```
数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
```

## 插入排序

### 直接插入排序

![img](https://img-blog.csdnimg.cn/20190920114119428.gif)

```
步骤
1）从第一个元素开始遍历数组
for(int i = 0 ; i < array.length ; i++){}
2）当第二个元素比第一个元素小的时候，将其往前移动
当第N个元素比N-1个元素小的时候，要一直往左移动直到碰到一个元素比第N个元素小，或者到达数组最左边
for(int j = i-1 ; j >= 0 ; j--){
   int tmp = array[i]
   if(array[j] > tmp) swap(array,i,j)； 当左边的元素比右边大的时候向左移动
   // 问题出在 array[i] 在和 array[j] 交换位置之后，原来 i  的位置就不是原来的值了
   // 要记下交换之后 array[i] 的值，放在这个if之前
   else break;
   // 当碰到比tmp小的值之后停止移动
   
   //通过上面的tmp本质上还是没有改变array[i]的位置
}
```

您的插入排序算法的问题在于第二个循环中对数组元素的交换。在交换元素时，您直接交换了`array[i]`和`array[j]`，但是这样会导致中间的元素丢失。正确的方法是将`array[j]`向右移动一位，然后将`tmp`赋值给`array[j+1]`。

这里是修改后的插入排序算法：

```java
public static void insertionSort(int[] array) {
    if (array == null || array.length <= 1) {
        return;
    }

    for (int i = 1; i < array.length; i++) {
        int tmp = array[i];
        int j = i - 1;
        while (j >= 0 && array[j] > tmp) {
            array[j + 1] = array[j]; // 将array[j]向右移动一位
            j--;
        }
        array[j + 1] = tmp; // 将tmp值赋给正确的位置
    }
}
```

 

```
问题解决之后的感悟：
插入排序重点 是插入：在插入的时候，先把要插入的位置上的 元素 向右移动一个位置，然后把元素插入进去
向右移动一个位置会把这个位置的元素覆盖了，所以先要用一个 tmp 来存储下这个元素
第二个for循环本质就是在 移动元素（像动图中的那样）
```

```java
        for(int i = 1; i < array.length; i++) { // 每循环一次，前 i 个数已经拍好序
            // 将这个数和之前的数比较
            // 一次外层递归本质上只比较一个数字，只将一个数组整理完毕
            int tmp = array[i];
            int j ;
            for(j = i - 1; j >= 0; j--) {
                if(array[j] > tmp){
                    array[j+1] = array[j];
                } else {
                    break;
                    // 当发现数组左边排好序的数，有一个比array[i]小的时候，说明前 i 个数已经排好了
                }
            }
            array[j+1] = tmp; // 全部移动完 才放入元素
        }
    }

    public void insertSort(int[] array){
        int i,j,tmp;
        for(i = 1; i < array.length; i++) {
            tmp = array[i];
            for(j = i - 1; j >= 0; j-- ) {
                if(tmp < array[j]){
                    array[j+1] = array[j];
                    array[j] = tmp; // 这样子是移动一次就放入一次
                }else{
                    break;
                }
            }
        }
    }
```

#### 复杂度分析

```
最坏：O(n^2)  逆序
最好：O(n)    有序
结论： 对于直接插入排序来说，数据越有序越快
场景： 当数据基本上是有序的时候，使用直接插入排序
稳定性：稳定
```

### 希尔排序（缩小增量排序）

```java
    public static void shellSort2(int[] array) {
        int gap = array.length / 2; //初始增量为数组长度的一半
        while (gap > 0) { //当增量大于0时，进行分组排序
            for (int i = gap; i < array.length; i++) { //对每个分组进行直接插入排序
                int temp = array[i]; //保存当前元素
//               int j = i; //记录当前元素的位置
//                while (j >= gap && array[j - gap] > temp) { //如果前一个元素大于当前元素，就交换位置
//                    array[j] = array[j - gap];
//                    j -= gap;
//                }
                int j;
                for(j = i - gap;j >= 0;j -= gap){
                    if(array[j] > temp){
                        array[j+gap] = array[j];
                    }else{
                        break;
                    }
                }
                array[j+=gap] = temp; //将当前元素插入到正确的位置
            }
            gap /= 2; //缩小增量
        }
    }
```

## 选择排序

### 直接选择排序

```java
    public static void directSelectSort(int[] array) {
        for(int i = 0 ; i < array.length - 1 ; i++) {
            int tmp = array[i];
            for(int j = i + 1; j < array.length ; j++){
                if(array[j] < tmp){
                    swap(array,j,i);
                }
            }

        }
    }
    private static void swap(int[] array,int i, int j) {
        int temp = array[j];
        array[j] = array[i];
        array[i] = temp;
    }
```

![image-20230507114520415](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507114520415.png)

```
代码优化： 不要每次比较就立马交换，而是内层for循环循环一层之后，再交换
```

![image-20230507114933645](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507114933645.png)

```java
    public static void selectSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            //每次将i下标的 值 当做是 最小值
            int minIndex = i;
            for (int j = i+1; j < array.length; j++) {
                if(array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            swap(array,minIndex,i);
        }
    }
    private static void swap(int[] array,int i, int j) {
        int temp = array[j];
        array[j] = array[i];
        array[i] = temp;
    }
```

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

#### 复杂度分析

```
时间复杂度：O(n^2)
空间复杂度：O(1)
```

```
有序
```

![image-20230507114933645](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507114933645.png)

```
无序
```

![image-20230507114453940](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507114453940.png)

```
有序和无序复杂度一样，有序情况下没有交换的那一步
```

![image-20230507120155577](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507120155577.png)

```
无序
```

![image-20230507120142659](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507120142659.png)

```
有序(逆序)
可以看出 逆序比无序 插入排序耗时大，说明越是按增序排列，插入排序越快，而选择排序无论是逆序还是无序，时间复杂度都是O（n^2）
```

![image-20230507120329239](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507120329239.png)

```
正序
明显看出，插入排序在 越是正序的情况下越快
```

![image-20230508092035019](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230508092035019.png)

```
选择排序一次记录两个下标
时间复杂度：O(n^2)
```

```java
    public static void selectSort2(int[] array) {
        int left = 0;
        int right = array.length - 1;
        while(left < right) {
            int minIndex = left;
            int maxIndex = left;
            // 一次记录两个下标
            for (int i = left + 1; i <= right ; i++) {//从第二个开始比较
                if(array[i] < array[minIndex]){
                    minIndex = i;
                }
                if(array[i] > array[maxIndex]) {
                    maxIndex = i;
                }
            }
            swap(array,left,minIndex);
            // 如果当 left 是 maxIndex 下标的时候，就会出错
            if(left == maxIndex) {
                maxIndex = minIndex;
            }
            swap(array,right,maxIndex);
            left++;
            right--;
        }
    }
```

## 堆排序

```java
    public static void heapSort(int[] array) {
        //创建大根堆
        createBigHeap(array);
        int end = array.length - 1;
        // 创建了大根堆之后，从上到下按照降序，但是同层的顺序无法保证
        while (end >= 0 ) { //
            swap(array,0,end);// 把最大的移到最后一个
            // end-- 防止后续shiftdown的时候，移动了最后一个元素
            end--;
           // 将堆顶的元素向下移动，把第二大的元素换上来
            shiftDown(array,0,end);
         
            
        }
    }

    private static void createBigHeap(int[] array) {
        for (int parent = (array.length-1-1)/2; parent >= 0 ; parent--){
            shiftDown(array,parent,array.length);
        }
    }
    private static void shiftDown(int[] array, int parent, int len){
        int child = 2 * parent + 1;
        while(child < len){
            if(child + 1 < len && array[child] < array[child+1]){
                child++;
            }
            if(array[child] > array[parent]){
                swap(array,child,parent);
                parent = child;
                child = 2 * parent + 1;
            }
        }
    }
```

### 时间复杂度分析：

- 建堆：从最后一个非叶子节点开始，自下而上，自右而左，对每个节点进行调整，使其满足大顶堆或小顶堆的性质。这个过程的时间复杂度是O(n)。  

- 排序：每次将堆顶元素与最后一个元素交换，然后对剩余的n-1个元素重新调整为堆，重复这个过程直到只剩一个元素。这个过程的时间复杂度是O(nlogn)。 

  ```
  所以时间复杂度是 O(nlogn)
  ```

  无序：

  ![image-20230508111749544](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230508111749544.png)

## 冒泡排序

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

```
外层 For 循环表示要 将多少个数排序
内层 for 循环表示 每次排序要移动几步
```



```java
    public static void bubbleSort(int[] array) {
        for(int i = 0 ; i < array.length-1; i++){ // 十个数据 九次for循环，十个数据九个gap
            for(int j = 0 ; j < array.length-1-i ; j++){// 每走一次外层for循环，内层就可以少走一次
                if(array[j] > array[j+1]){
                    swap(array,j,j+1);
                }
            }
        }
    }
```

#### 时间复杂度

```java
时间复杂度：O(n^2)
优化：
    public static void bubbleSort(int[] array) {
        for(int i = 0 ; i < array.length-1; i++){ // 十个数据 九次for循环，十个数据九个gap
            boolean flg = false;
            for(int j = 0 ; j < array.length-1-i ; j++){// 每走一次外层for循环，内层就可以少走一次
                if(array[j] > array[j+1]){
                    swap(array,j,j+1);
                }
            }
            if(!flg) {
                break;
            }
        }
    }
当有序情况下时间复杂度: O(n^2)
稳定性：稳定
空间复杂度：O(1)
```

## 快速排序

![image-20230509111717079](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509111717079.png)

```
L 从左边开始走， R 从右边开始走
当 R 碰到比 key 小的数就停下来，让 L 走
L 碰到比 key 大的数就停下来
然后L,R交换位置上的数
```

![image-20230509111916543](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509111916543.png)

![image-20230509111924529](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509111924529.png)

```
交换完之后 ，R继续先走
当 R 碰到比 key 小的数就停下来，让 L 走
L 碰到比 key 大的数就停下来
```

![image-20230509112025957](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509112025957.png)

```
此时 R 再往前走，碰到比6小的停下来
L 也往前走，LR相遇了，然后就将相遇位置的值和 key交换
```

![image-20230509112133575](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509112133575.png)

![image-20230509112143248](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509112143248.png)

![image-20230509112159517](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509112159517.png)

```
这个时候，因为 L 将 最终相遇位置的左边 的值比 key大的都和 相遇位置 右边比 key 小的交换了，最终相遇点的值也是比 key 小的，然后将相遇点 和 key交换，将相遇点设为key
此时 key 左边的值都比 key 小， key 右边的值都比 key 大
```



```
问题1：最左边元素做key，为什么最右边元素先走？
```

![image-20230509113800911](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509113800911.png)

![image-20230509113822153](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509113822153.png)

![image-20230509113837993](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509113837993.png)

![image-20230509113944778](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230509113944778.png)

```
左边先走的问题：最后相遇的地方一定比基准值大的值
    1）当左边移动时两者相遇：当左边先走，碰到比pivot大的停下来，右边走，碰到比pivot小的停下来，然后交换，此时左边再走当碰到Pivot的时候，相遇的点是上次左边碰到的比pivot大的值交换过去的，所以相遇点一定比pivot大 
    2) 当右边移动时两者相遇，当左边不移动，说明左边遇到比 pivot 大的值，所以停下来了，此时右边在找比 pivot小的值，如果此时两者相遇，则在左边指针的位置，即比 pivot 大的值
通过上述两种情况可以看出，当左边先走，相遇点一定比pivot大，因为要么是右边指针没有交换过的（比pivot)大的值,要么是左边碰到比Pivot大的值，然后右边撞上来了，所以左边先走就会导致 pivot 交换之后，pivot的值太大
```



快速排序（Quick Sort）是一种分治算法，通过选定一个基准值（pivot）将数组分为两部分，一部分是比基准值小的元素，另一部分是比基准值大的元素。然后对这两部分分别递归地应用快速排序，直到整个数组有序。

下面是用Java实现快速排序的步骤：

1. 定义一个递归方法 `quickSort` 接收三个参数：数组（array），左边界（left）和右边界（right）。
2. 在 `quickSort` 方法中，首先判断左边界是否小于右边界，若否则直接返回。
3. 选定一个基准值（pivot），通常可以选择数组的第一个元素或者随机选择。
4. 使用一个名为 `partition` 的方法将数组分为两部分，该方法返回基准值的最终位置。
5. 递归地对左边和右边的子数组进行快速排序。

以下是使用Java实现的快速排序示例代码：

```java
public class QuickSort {

    public static void quickSort(int[] array, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(array, left, right);
            quickSort(array, left, pivotIndex - 1);
            quickSort(array, pivotIndex + 1, right);
        }
    }

    private static int partition(int[] array, int left, int right) {
        int pivot = array[left];
        int i = left + 1;
        int j = right;

        while (true) {
            while (i < j && array[j] > pivot) {
                j--;
            }
            while (i < j && array[i] < pivot) {
                i++;
            }
            if (i < j) {
                swap(array, i, j);
            } else {
                break;
            }
        }

        swap(array, left, j);
        return j;
    }

    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static void main(String[] args) {
        int[] array = {3, 8, 2, 5, 1, 4, 7, 6};
        quickSort(array, 0, array.length - 1);

        for (int value : array) {
            System.out.print(value + " ");
        }
    }
}
```

当你运行上述代码时，数组将会按照升序排列。你可以根据需要对其进行修改以满足特定需求。