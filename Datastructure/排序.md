# 排序

## 排序的概念

### 1.排序的概念

#### 稳定性

![image-20230505100553302](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230505100553302.png)

```
两个相同的数，排序前的 前后顺序 和排序后的 前后顺序 一样，既是稳定的
```

#### 内部排序

```
全部元素都放在内存中排序
```

#### 外部排序

```
数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
```

## 插入排序

### 直接插入排序

![img](https://img-blog.csdnimg.cn/20190920114119428.gif)

```
步骤
1）从第一个元素开始遍历数组
for(int i = 0 ; i < array.length ; i++){}
2）当第二个元素比第一个元素小的时候，将其往前移动
当第N个元素比N-1个元素小的时候，要一直往左移动直到碰到一个元素比第N个元素小，或者到达数组最左边
for(int j = i-1 ; j >= 0 ; j--){
   int tmp = array[i]
   if(array[j] > tmp) swap(array,i,j)； 当左边的元素比右边大的时候向左移动
   // 问题出在 array[i] 在和 array[j] 交换位置之后，原来 i  的位置就不是原来的值了
   // 要记下交换之后 array[i] 的值，放在这个if之前
   else break;
   // 当碰到比tmp小的值之后停止移动
   
   //通过上面的tmp本质上还是没有改变array[i]的位置
}
```

您的插入排序算法的问题在于第二个循环中对数组元素的交换。在交换元素时，您直接交换了`array[i]`和`array[j]`，但是这样会导致中间的元素丢失。正确的方法是将`array[j]`向右移动一位，然后将`tmp`赋值给`array[j+1]`。

这里是修改后的插入排序算法：

```java
public static void insertionSort(int[] array) {
    if (array == null || array.length <= 1) {
        return;
    }

    for (int i = 1; i < array.length; i++) {
        int tmp = array[i];
        int j = i - 1;
        while (j >= 0 && array[j] > tmp) {
            array[j + 1] = array[j]; // 将array[j]向右移动一位
            j--;
        }
        array[j + 1] = tmp; // 将tmp值赋给正确的位置
    }
}
```

 

```
问题解决之后的感悟：
插入排序重点 是插入：在插入的时候，先把要插入的位置上的 元素 向右移动一个位置，然后把元素插入进去
向右移动一个位置会把这个位置的元素覆盖了，所以先要用一个 tmp 来存储下这个元素
第二个for循环本质就是在 移动元素（像动图中的那样）
```

```java
        for(int i = 1; i < array.length; i++) { // 每循环一次，前 i 个数已经拍好序
            // 将这个数和之前的数比较
            // 一次外层递归本质上只比较一个数字，只将一个数组整理完毕
            int tmp = array[i];
            int j ;
            for(j = i - 1; j >= 0; j--) {
                if(array[j] > tmp){
                    array[j+1] = array[j];
                } else {
                    break;
                    // 当发现数组左边排好序的数，有一个比array[i]小的时候，说明前 i 个数已经排好了
                }
            }
            array[j+1] = tmp; // 全部移动完 才放入元素
        }
    }

    public void insertSort(int[] array){
        int i,j,tmp;
        for(i = 1; i < array.length; i++) {
            tmp = array[i];
            for(j = i - 1; j >= 0; j-- ) {
                if(tmp < array[j]){
                    array[j+1] = array[j];
                    array[j] = tmp; // 这样子是移动一次就放入一次
                }else{
                    break;
                }
            }
        }
    }
```

#### 复杂度分析

```
最坏：O(n^2)  逆序
最好：O(n)    有序
结论： 对于直接插入排序来说，数据越有序越快
场景： 当数据基本上是有序的时候，使用直接插入排序
稳定性：稳定
```

### 希尔排序（缩小增量排序）

```java
    public static void shellSort2(int[] array) {
        int gap = array.length / 2; //初始增量为数组长度的一半
        while (gap > 0) { //当增量大于0时，进行分组排序
            for (int i = gap; i < array.length; i++) { //对每个分组进行直接插入排序
                int temp = array[i]; //保存当前元素
//               int j = i; //记录当前元素的位置
//                while (j >= gap && array[j - gap] > temp) { //如果前一个元素大于当前元素，就交换位置
//                    array[j] = array[j - gap];
//                    j -= gap;
//                }
                int j;
                for(j = i - gap;j >= 0;j -= gap){
                    if(array[j] > temp){
                        array[j+gap] = array[j];
                    }else{
                        break;
                    }
                }
                array[j+=gap] = temp; //将当前元素插入到正确的位置
            }
            gap /= 2; //缩小增量
        }
    }
```

## 选择排序

### 直接选择排序

```java
    public static void directSelectSort(int[] array) {
        for(int i = 0 ; i < array.length - 1 ; i++) {
            int tmp = array[i];
            for(int j = i + 1; j < array.length ; j++){
                if(array[j] < tmp){
                    swap(array,j,i);
                }
            }

        }
    }
    private static void swap(int[] array,int i, int j) {
        int temp = array[j];
        array[j] = array[i];
        array[i] = temp;
    }
```

![image-20230507114520415](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507114520415.png)

```
代码优化： 不要每次比较就立马交换，而是内层for循环循环一层之后，再交换
```

![image-20230507114933645](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507114933645.png)

```java
    public static void selectSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            //每次将i下标的 值 当做是 最小值
            int minIndex = i;
            for (int j = i+1; j < array.length; j++) {
                if(array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            swap(array,minIndex,i);
        }
    }
    private static void swap(int[] array,int i, int j) {
        int temp = array[j];
        array[j] = array[i];
        array[i] = temp;
    }
```

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

#### 复杂度分析

```
时间复杂度：O(n^2)
空间复杂度：O(1)
```

```
有序
```

![image-20230507114933645](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507114933645.png)

```
无序
```

![image-20230507114453940](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507114453940.png)

```
有序和无序复杂度一样，有序情况下没有交换的那一步
```

![image-20230507120155577](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507120155577.png)

```
无序
```

![image-20230507120142659](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507120142659.png)

```
有序(逆序)
可以看出 逆序比无序 插入排序耗时大，说明越是按增序排列，插入排序越快，而选择排序无论是逆序还是无序，时间复杂度都是O（n^2）
```

![image-20230507120329239](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230507120329239.png)

