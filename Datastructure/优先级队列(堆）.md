# 堆

## 堆的介绍

```
大根堆
```

![image-20230429204227306](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230429204227306.png)

```
小根堆
```

![image-20230429204237872](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230429204237872.png)

```
逻辑结构上是一个完全二叉树
实际存储结构是一个数组
这棵树是一棵完全二叉树适合用数组来存储，不会有资源的浪费 
```

![image-20230429204638549](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230429204638549.png)

```
将 优先级队列 进行模拟实现的时候，其实 就是将二叉树 使用数组的形式 来进行存储
```

## 将一个大根堆变成二叉树

![image-20230429205723485](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230429205723485.png)

![image-20230429210050162](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230429210050162.png)

```
第一次把49，18交换，37，28交换，19，65交换
```

![image-20230429210141307](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230429210141307.png)

```
然后再把 49,15交换，65，27交换
```

![image-20230429210308794](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230429210308794.png)

![image-20230429214023005](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230429214023005.png) 

```
就获得一个大根堆
```

```
调整方式：【向下调整】
从每棵子树的根节点开始进行调整
每棵子树的调整属于 向下调整
```

```
1.如何确定最后一棵子树的根节点的位置
如果确定最后一棵子树的最后一个节点【孩子节点】 len-1=9
确定孩子节点[i] 怎么确定 父亲节点 （i-1）/2
总结：最后一棵子树的根节点 = (len-1-1)/2
2.从最后一个叶子节点开始，如何确定下一棵子树的根节点
当前根节点-1（因为是层序遍历组成的数组，所以下一个子树的根节点就是下一个节点）
3.最终结论： 其实就是主要去写 每棵子树的调整即可
```

```
让我们一步步分析为什么在创建大根堆时，`shiftDown` 函数需要将 `usedSize` 作为参数。

1. 初始化大根堆：创建大根堆时，我们需要一个数组来存储元素。`usedSize` 表示当前数组中有效元素的个数，即实际参与构建堆的元素数量。

2. 确定起始调整位置：为了创建大根堆，我们需要从最后一个叶子节点的父节点开始向上逐层调整。调整过程中，我们需要确保不会访问数组之外的元素。在这里，`usedSize` 可以帮助我们计算这个起始父节点的索引，即 `(usedSize - 1 - 1) / 2`。

3. 调用 `shiftDown` 函数：为了将每个父节点调整至正确的位置，我们需要调用 `shiftDown` 函数。这个函数需要知道当前数组的有效长度，以确保在调整堆时不会访问数组之外的元素。这就是为什么我们需要将 `usedSize` 作为 `shiftDown` 函数的参数。

4. ***** `shiftDown` 函数中的循环：在 `shiftDown` 函数中，我们需要通过循环不断向下调整父节点。在每次循环中，我们都需要检查左右子节点的索引是否在有效范围内（即小于 `usedSize`），以防止访问到无效的数组元素。这就是为什么我们需要将 `usedSize` 作为 `shiftDown` 函数的参数。

总结：在通过数组创建大根堆时，`shiftDown` 函数的第二个参数是 `usedSize`，因为这个参数表示当前数组中有效元素的个数。在整个创建堆的过程中，我们需要使用这个长度限制来确保在调整堆时不会访问数组之外的元素。这对于正确构建大根堆和避免访问无效数组元素至关重要。
```

```
初始化堆
```

```java
    // 堆的本质是一个数组
    public int[] elem;

    // usedSize 表示当前数组中有效元素的个数，即实际参与构建堆的元素数量。
    public int usedSize;

    // 初始化 堆 ：长度为 10 的数组，最开始数组中没有存入元素 userSize 为 0
    public TestHeap() {
        this.elem = new int[10];
        this.usedSize = 0;
    }

    // 初始化一个数组，将传入的数组赋值给 elem, usedSize 是数组的长度
    public void initArray(int[] array) {
        elem = Arrays.copyOf(array,array.length);
        usedSize = elem.length;
    }
```

```
创建一个大根堆
```

```java
    //建堆: 大根堆
    public void createHeap(){
        // for 循环开始值为最后一个叶子节点的父节点
        for(int parent = (usedSize-1-1) / 2; parent >= 0 ; parent--) {
            // 从最后一个叶子节点的父节点开始循环，直到根节点
            // 每次比较的parent节点和他的所有子节点 *****
            shiftDown(parent, usedSize);
        }
    }
```

```
交换父节点和字节点
```

```java
    /**
     * 实现 向下调整，将父节点和子节点的值进行比较并交换
     * @param parent 每棵子树的根节点的下标
     * @param len 每棵子树的结束位置
     */
    private void shiftDown(int parent, int len) {
        int child = 2 * parent + 1;
        // 当左孩子的下标没有超出数组的长度，说明左孩子存在
        // 用 while 循环因为会一直比较一个节点和它的所有子节点的大小，直到判断到叶子节点
        while (child < len) {

            // 比较左孩子和右孩子哪个值比较大，判断的前提是有右孩子，前面while循环只判断了 child 存在
            // 而不知道右孩子是否存在 ， 所以 if 中要加上 child+1 < usedSize
            if(child + 1 < usedSize && elem[child] < elem[child+1]) {
                // 此时保存了左右孩子节点中最大值的下标
                child++;
            }
            // 上述if判断了左孩子节点和右孩子节点哪一个大，且 child 位于大的孩子节点的下标位置
            // 接下来开始判断孩子节点和父亲节点哪一个比较大，如果孩子节点比较大，就进行交换
            if(elem[child] > elem[parent]) {
                // 交换父节点和子节点的值
                swap(elem,child,parent);
                /*在创建大根堆的过程中，需要更新子节点的索引是因为我们要确保整个子树都满足大根堆的性质。当父节点与子节点交换后，我们需要继续检查被交换下来的节点是否满足大根堆的性质。
考虑这样一个情况：当一个父节点的值小于其子节点的值时，我们需要将它们的值进行交换。然而，仅仅交换一次可能还不足以使整个子树满足大根堆的性质。这是因为在交换后，原来较小的父节点值被放置在子节点的位置，可能仍然小于它的新子节点。在这种情况下，我们需要继续进行交换操作，直到该节点满足大根堆的性质或者到达叶子节点。
为了实现这个过程，我们需要在每次交换后更新父子节点的索引。通过将父节点索引更新为刚刚交换的子节点索引，我们可以在下一次循环中检查新的子节点。同样，我们需要更新子节点的索引，以便在下一次循环中检查正确的子节点。
总之，更新子节点的索引是为了确保在创建大根堆时，整个子树都满足大根堆的性质。这样可以保证当一个节点的值被交换到子节点位置时，我们仍然能够正确地向下调整堆结构。*/
                // 将父节点的索引变成比它大的子节点的索引
                parent = child;
                // 将比父节点大的子节点的索引换成 子节点的左孩子节点的索引（此时parent等于child)
                // child = 2 * child + 1;
                child = 2*parent+1;
            }else {
                //父亲节点大于孩子节点，满足大根堆
                break;
            }
        }
    }

    private void swap(int[] array, int i , int j ){
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;

    }
```

### 时间复杂度分析

![image-20230430214021059](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230430214021059.png)

```
每一层的节点个数为 2^(n-1) n为层次
每一层最多要遍历的子节点个数为 h - n , h 为高度 （ 其实就是到叶子节点的长度，可以从上图中直观看出来）

所以时间复杂度为

```

![image-20230430214333575](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230430214333575.png)

```
即每一个节点要遍历的节点数之和
```

```
计算值：
```

![image-20230430214425573](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230430214425573.png)

![image-20230430214446995](C:\Users\方锐\AppData\Roaming\Typora\typora-user-images\image-20230430214446995.png)